# -*- warn-indent:false;  -*-

# line 1 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"

# line 771 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"


# THIS IS A GENERATED FILE, DO NOT EDIT DIRECTLY
# This file was generated from lib/regexp_parser/scanner/scanner.rl

class Regexp::Scanner
  # General scanner error (catch all)
  class ScannerError < StandardError; end

  # Base for all scanner validation errors
  class ValidationError < StandardError
    def initialize(reason)
      super reason
    end
  end

  # Unexpected end of pattern
  class PrematureEndError < ScannerError
    def initialize(where = '')
      super "Premature end of pattern at #{where}"
    end
  end

  # Invalid sequence format. Used for escape sequences, mainly.
  class InvalidSequenceError < ValidationError
    def initialize(what = 'sequence', where = '')
      super "Invalid #{what} at #{where}"
    end
  end

  # Invalid group. Used for named groups.
  class InvalidGroupError < ValidationError
    def initialize(what, reason)
      super "Invalid #{what}, #{reason}."
    end
  end

  # Invalid groupOption. Used for inline options.
  class InvalidGroupOption < ValidationError
    def initialize(option, text)
      super "Invalid group option #{option} in #{text}"
    end
  end

  # Invalid back reference. Used for name a number refs/calls.
  class InvalidBackrefError < ValidationError
    def initialize(what, reason)
      super "Invalid back reference #{what}, #{reason}"
    end
  end

  # The property name was not recognized by the scanner.
  class UnknownUnicodePropertyError < ValidationError
    def initialize(name)
      super "Unknown unicode character property name #{name}"
    end
  end

  # Scans the given regular expression text, or Regexp object and collects the
  # emitted token into an array that gets returned at the end. If a block is
  # given, it gets called for each emitted token.
  #
  # This method may raise errors if a syntax error is encountered.
  # --------------------------------------------------------------------------
  def self.scan(input_object, &block)
    new.scan(input_object, &block)
  end

  def scan(input_object, &block)
    self.literal = nil
    stack = []

    if input_object.is_a?(Regexp)
      input = input_object.source
      self.free_spacing = (input_object.options & Regexp::EXTENDED != 0)
    else
      input = input_object
      self.free_spacing = false
    end


    data  = input.unpack("c*") if input.is_a?(String)
    eof   = data.length

    self.tokens = []
    self.block  = block_given? ? block : nil

    self.in_group = false
    self.group_depth = 0
    self.spacing_stack = [{:free_spacing => free_spacing, :depth => 0}]

    in_set, set_depth, set_type = false, 0, :set
    in_conditional, conditional_depth, conditional_stack = false, 0, []

    
# line 101 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner.rb"
class << self
	attr_accessor :_re_scanner_trans_keys
	private :_re_scanner_trans_keys, :_re_scanner_trans_keys=
end
self._re_scanner_trans_keys = [
	0, 0, -128, -65, -128, -65, 
	-128, -65, -128, -65, -128, 
	-65, -128, -65, 10, 10, 
	33, 126, 41, 41, 39, 122, 
	33, 122, 48, 122, 39, 
	60, 39, 122, 48, 57, 
	39, 57, 48, 57, 39, 57, 
	39, 122, 43, 122, 48, 
	57, 48, 62, 48, 57, 
	43, 62, 43, 122, 44, 125, 
	48, 125, 123, 123, 9, 
	122, 9, 125, 9, 125, 
	9, 125, 9, 125, 49, 57, 
	46, 48, 49, 49, 125, 
	125, 46, 46, 48, 48, 
	46, 46, 48, 49, 46, 46, 
	48, 50, 46, 46, 48, 
	51, 9, 122, -128, -65, 
	-128, -65, -128, -65, -128, -65, 
	-128, -65, -128, -65, 48, 
	122, 45, 122, 45, 122, 
	93, 93, 94, 120, 97, 120, 
	108, 115, 110, 112, 117, 
	117, 109, 109, 58, 58, 
	93, 93, 104, 104, 97, 97, 
	99, 99, 105, 105, 105, 
	105, 108, 108, 97, 97, 
	110, 110, 107, 107, 110, 110, 
	116, 116, 114, 114, 108, 
	108, 105, 105, 103, 103, 
	105, 105, 116, 116, 114, 114, 
	97, 97, 112, 112, 104, 
	104, 111, 111, 119, 119, 
	101, 101, 114, 114, 114, 117, 
	105, 105, 110, 110, 110, 
	110, 99, 99, 112, 112, 
	97, 97, 99, 99, 101, 101, 
	112, 112, 112, 112, 111, 
	111, 114, 114, 100, 100, 
	100, 100, 65, 122, 61, 61, 
	93, 93, -128, -65, -128, 
	-65, -128, -65, -128, -65, 
	-128, -65, -128, -65, 92, 92, 
	120, 120, 48, 102, 45, 
	45, 77, 77, 45, 45, 
	45, 45, 67, 99, 45, 45, 
	77, 77, 45, 45, 48, 
	123, 48, 102, 48, 102, 
	48, 102, 48, 102, 9, 125, 
	9, 125, 9, 125, 9, 
	125, 9, 125, 48, 123, 
	9, 125, 9, 125, 41, 41, 
	39, 122, 41, 57, 48, 
	122, -62, 127, -62, -33, 
	-32, -17, -16, -12, 1, 127, 
	1, 127, 9, 32, 33, 
	126, 10, 126, 63, 63, 
	43, 63, 43, 63, 43, 63, 
	65, 122, 43, 63, 80, 
	112, -62, 127, -128, -65, 
	-62, -33, -128, -65, -32, -17, 
	-128, -65, -16, -12, 1, 
	127, 38, 38, 93, 93, 
	45, 45, 46, 61, -62, 127, 
	-62, -33, -32, -17, -16, 
	-12, 1, 127, 32, 126, 
	32, 126, 32, 126, 48, 102, 
	32, 126, 36, 125, 48, 
	55, 48, 55, 92, 92, 
	92, 92, 92, 92, 48, 102, 
	125, 125, 125, 125, 125, 
	125, 125, 125, 125, 125, 
	125, 125, 125, 125, 125, 125, 
	9, 125, 9, 125, 9, 
	125, 9, 125, 9, 125, 
	9, 125, 9, 125, 9, 32, 
	9, 125, 48, 125, 48, 
	125, 48, 125, 48, 125, 
	48, 125, 48, 125, 48, 125, 
	125, 125, 39, 60, 39, 
	122, 49, 57, 41, 57, 
	48, 122, 0
]

class << self
	attr_accessor :_re_scanner_key_spans
	private :_re_scanner_key_spans, :_re_scanner_key_spans=
end
self._re_scanner_key_spans = [
	0, 64, 64, 64, 64, 64, 64, 1, 
	94, 1, 84, 90, 75, 22, 84, 10, 
	19, 10, 19, 84, 80, 10, 15, 10, 
	20, 80, 82, 78, 1, 114, 117, 117, 
	117, 117, 9, 3, 1, 1, 1, 1, 
	1, 2, 1, 3, 1, 4, 114, 64, 
	64, 64, 64, 64, 64, 75, 78, 78, 
	1, 27, 24, 8, 3, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 4, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 58, 1, 1, 64, 64, 64, 64, 
	64, 64, 1, 1, 55, 1, 1, 1, 
	1, 33, 1, 1, 1, 76, 55, 55, 
	55, 55, 117, 117, 117, 117, 117, 76, 
	117, 117, 1, 84, 17, 75, 190, 30, 
	16, 5, 127, 127, 24, 94, 117, 1, 
	21, 21, 21, 58, 21, 33, 190, 64, 
	30, 64, 16, 64, 5, 127, 1, 1, 
	1, 16, 190, 30, 16, 5, 127, 95, 
	95, 95, 55, 95, 90, 8, 8, 1, 
	1, 1, 55, 1, 1, 1, 1, 1, 
	1, 1, 1, 117, 117, 117, 117, 117, 
	117, 117, 24, 117, 78, 78, 78, 78, 
	78, 78, 78, 1, 22, 84, 9, 17, 
	75
]

class << self
	attr_accessor :_re_scanner_index_offsets
	private :_re_scanner_index_offsets, :_re_scanner_index_offsets=
end
self._re_scanner_index_offsets = [
	0, 0, 65, 130, 195, 260, 325, 390, 
	392, 487, 489, 574, 665, 741, 764, 849, 
	860, 880, 891, 911, 996, 1077, 1088, 1104, 
	1115, 1136, 1217, 1300, 1379, 1381, 1496, 1614, 
	1732, 1850, 1968, 1978, 1982, 1984, 1986, 1988, 
	1990, 1992, 1995, 1997, 2001, 2003, 2008, 2123, 
	2188, 2253, 2318, 2383, 2448, 2513, 2589, 2668, 
	2747, 2749, 2777, 2802, 2811, 2815, 2817, 2819, 
	2821, 2823, 2825, 2827, 2829, 2831, 2833, 2835, 
	2837, 2839, 2841, 2843, 2845, 2847, 2849, 2851, 
	2853, 2855, 2857, 2859, 2861, 2863, 2865, 2867, 
	2869, 2871, 2873, 2878, 2880, 2882, 2884, 2886, 
	2888, 2890, 2892, 2894, 2896, 2898, 2900, 2902, 
	2904, 2906, 2965, 2967, 2969, 3034, 3099, 3164, 
	3229, 3294, 3359, 3361, 3363, 3419, 3421, 3423, 
	3425, 3427, 3461, 3463, 3465, 3467, 3544, 3600, 
	3656, 3712, 3768, 3886, 4004, 4122, 4240, 4358, 
	4435, 4553, 4671, 4673, 4758, 4776, 4852, 5043, 
	5074, 5091, 5097, 5225, 5353, 5378, 5473, 5591, 
	5593, 5615, 5637, 5659, 5718, 5740, 5774, 5965, 
	6030, 6061, 6126, 6143, 6208, 6214, 6342, 6344, 
	6346, 6348, 6365, 6556, 6587, 6604, 6610, 6738, 
	6834, 6930, 7026, 7082, 7178, 7269, 7278, 7287, 
	7289, 7291, 7293, 7349, 7351, 7353, 7355, 7357, 
	7359, 7361, 7363, 7365, 7483, 7601, 7719, 7837, 
	7955, 8073, 8191, 8216, 8334, 8413, 8492, 8571, 
	8650, 8729, 8808, 8887, 8889, 8912, 8997, 9007, 
	9025
]

class << self
	attr_accessor :_re_scanner_indicies
	private :_re_scanner_indicies, :_re_scanner_indicies=
end
self._re_scanner_indicies = [
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	0, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 
	2, 0, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 0, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 0, 5, 5, 5, 5, 
	5, 5, 5, 5, 5, 5, 5, 5, 
	5, 5, 5, 5, 5, 5, 5, 5, 
	5, 5, 5, 5, 5, 5, 5, 5, 
	5, 5, 5, 5, 5, 5, 5, 5, 
	5, 5, 5, 5, 5, 5, 5, 5, 
	5, 5, 5, 5, 5, 5, 5, 5, 
	5, 5, 5, 5, 5, 5, 5, 5, 
	5, 5, 5, 5, 0, 6, 6, 6, 
	6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6, 6, 6, 6, 0, 9, 8, 
	11, 10, 12, 10, 10, 10, 13, 14, 
	10, 10, 10, 10, 15, 10, 10, 10, 
	10, 10, 10, 10, 10, 10, 10, 10, 
	10, 16, 10, 17, 11, 16, 10, 10, 
	10, 10, 10, 10, 10, 10, 10, 10, 
	10, 10, 10, 10, 10, 10, 10, 10, 
	10, 10, 10, 10, 10, 10, 10, 10, 
	10, 10, 10, 10, 10, 10, 10, 10, 
	15, 10, 10, 15, 10, 10, 10, 10, 
	15, 10, 10, 10, 15, 10, 10, 10, 
	10, 10, 10, 10, 15, 10, 10, 15, 
	10, 10, 10, 10, 10, 16, 10, 18, 
	12, 16, 10, 10, 10, 10, 10, 10, 
	10, 10, 13, 13, 13, 13, 13, 13, 
	13, 13, 13, 13, 10, 10, 10, 10, 
	10, 10, 10, 13, 13, 13, 13, 13, 
	13, 13, 13, 13, 13, 13, 13, 13, 
	13, 13, 13, 13, 13, 13, 13, 13, 
	13, 13, 13, 13, 13, 10, 10, 10, 
	10, 13, 10, 13, 13, 13, 13, 13, 
	13, 13, 13, 13, 13, 13, 13, 13, 
	13, 13, 13, 13, 13, 13, 13, 13, 
	13, 13, 13, 13, 13, 10, 11, 10, 
	10, 10, 10, 10, 10, 10, 10, 10, 
	10, 10, 10, 10, 10, 19, 19, 19, 
	19, 19, 19, 19, 19, 19, 19, 10, 
	10, 10, 11, 16, 10, 10, 19, 19, 
	19, 19, 19, 19, 19, 19, 19, 19, 
	19, 19, 19, 19, 19, 19, 19, 19, 
	19, 19, 19, 19, 19, 19, 19, 19, 
	10, 10, 10, 10, 19, 10, 19, 19, 
	19, 19, 19, 19, 19, 19, 19, 19, 
	19, 19, 19, 19, 19, 19, 19, 19, 
	19, 19, 19, 19, 19, 19, 19, 19, 
	10, 19, 19, 19, 19, 19, 19, 19, 
	19, 19, 19, 10, 10, 10, 10, 16, 
	10, 10, 19, 19, 19, 19, 19, 19, 
	19, 19, 19, 19, 19, 19, 19, 19, 
	19, 19, 19, 19, 19, 19, 19, 19, 
	19, 19, 19, 19, 10, 10, 10, 10, 
	19, 10, 19, 19, 19, 19, 19, 19, 
	19, 19, 19, 19, 19, 19, 19, 19, 
	19, 19, 19, 19, 19, 19, 19, 19, 
	19, 19, 19, 19, 10, 21, 20, 20, 
	20, 20, 20, 20, 20, 20, 20, 20, 
	20, 20, 20, 20, 20, 20, 20, 20, 
	20, 20, 22, 20, 23, 20, 20, 20, 
	24, 20, 25, 20, 20, 26, 26, 26, 
	26, 26, 26, 26, 26, 26, 26, 20, 
	20, 20, 20, 20, 20, 20, 26, 26, 
	26, 26, 26, 26, 26, 26, 26, 26, 
	26, 26, 26, 26, 26, 26, 26, 26, 
	26, 26, 26, 26, 26, 26, 26, 26, 
	20, 20, 20, 20, 26, 20, 26, 26, 
	26, 26, 26, 26, 26, 26, 26, 26, 
	26, 26, 26, 26, 26, 26, 26, 26, 
	26, 26, 26, 26, 26, 26, 26, 26, 
	20, 27, 27, 27, 27, 27, 27, 27, 
	27, 27, 27, 20, 23, 20, 20, 20, 
	20, 20, 20, 20, 20, 27, 27, 27, 
	27, 27, 27, 27, 27, 27, 27, 20, 
	27, 28, 28, 28, 28, 28, 28, 28, 
	28, 28, 20, 23, 20, 20, 20, 24, 
	20, 24, 20, 20, 28, 28, 28, 28, 
	28, 28, 28, 28, 28, 28, 20, 23, 
	20, 20, 20, 24, 20, 24, 20, 20, 
	26, 26, 26, 26, 26, 26, 26, 26, 
	26, 26, 20, 20, 20, 20, 20, 20, 
	20, 26, 26, 26, 26, 26, 26, 26, 
	26, 26, 26, 26, 26, 26, 26, 26, 
	26, 26, 26, 26, 26, 26, 26, 26, 
	26, 26, 26, 20, 20, 20, 20, 26, 
	20, 26, 26, 26, 26, 26, 26, 26, 
	26, 26, 26, 26, 26, 26, 26, 26, 
	26, 26, 26, 26, 26, 26, 26, 26, 
	26, 26, 26, 20, 29, 20, 30, 20, 
	20, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 20, 20, 20, 20, 23, 
	20, 20, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 20, 20, 20, 20, 
	31, 20, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 20, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 20, 
	32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 20, 20, 20, 20, 23, 20, 
	32, 33, 33, 33, 33, 33, 33, 33, 
	33, 33, 20, 29, 20, 29, 20, 20, 
	33, 33, 33, 33, 33, 33, 33, 33, 
	33, 33, 20, 20, 20, 20, 23, 20, 
	29, 20, 29, 20, 20, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 20, 
	20, 20, 20, 23, 20, 20, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 
	20, 20, 20, 20, 31, 20, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 
	20, 35, 34, 34, 34, 36, 36, 36, 
	36, 36, 36, 36, 36, 36, 36, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 37, 34, 35, 35, 35, 35, 
	35, 35, 35, 35, 35, 35, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 
	34, 37, 34, 38, 39, 40, 40, 40, 
	40, 40, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 40, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 40, 39, 39, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 39, 39, 
	39, 39, 39, 39, 39, 41, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 39, 
	39, 39, 42, 40, 39, 41, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 39, 
	40, 40, 40, 40, 40, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 40, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 40, 39, 39, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 39, 39, 39, 39, 39, 39, 39, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 39, 39, 39, 39, 40, 39, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 39, 39, 43, 39, 40, 40, 
	40, 40, 40, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 40, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 40, 39, 39, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 39, 
	39, 39, 39, 39, 39, 39, 40, 40, 
	40, 40, 40, 40, 44, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	39, 39, 39, 39, 40, 39, 40, 40, 
	40, 40, 40, 40, 44, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	39, 39, 43, 39, 40, 40, 40, 40, 
	40, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 40, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	40, 39, 39, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 39, 39, 39, 
	39, 39, 39, 39, 40, 40, 40, 40, 
	45, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 39, 39, 
	39, 39, 40, 39, 40, 40, 40, 40, 
	45, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 39, 39, 
	43, 39, 40, 40, 40, 40, 40, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 40, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 40, 39, 
	39, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 39, 39, 39, 46, 39, 
	39, 39, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 39, 39, 39, 39, 
	40, 39, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 39, 39, 43, 39, 
	47, 48, 49, 48, 49, 50, 51, 51, 
	51, 39, 52, 39, 51, 39, 53, 39, 
	43, 39, 54, 39, 53, 39, 55, 39, 
	53, 53, 39, 56, 39, 53, 53, 53, 
	39, 57, 39, 53, 53, 53, 53, 39, 
	40, 40, 40, 40, 40, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 40, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 40, 39, 39, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 39, 39, 39, 39, 39, 39, 39, 
	41, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 39, 39, 39, 39, 40, 39, 
	41, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 39, 59, 59, 59, 59, 59, 
	59, 59, 59, 59, 59, 59, 59, 59, 
	59, 59, 59, 59, 59, 59, 59, 59, 
	59, 59, 59, 59, 59, 59, 59, 59, 
	59, 59, 59, 59, 59, 59, 59, 59, 
	59, 59, 59, 59, 59, 59, 59, 59, 
	59, 59, 59, 59, 59, 59, 59, 59, 
	59, 59, 59, 59, 59, 59, 59, 59, 
	59, 59, 59, 58, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 60, 60, 60, 60, 
	60, 60, 60, 60, 58, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 58, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 62, 62, 
	62, 62, 62, 62, 62, 62, 58, 63, 
	63, 63, 63, 63, 63, 63, 63, 63, 
	63, 63, 63, 63, 63, 63, 63, 63, 
	63, 63, 63, 63, 63, 63, 63, 63, 
	63, 63, 63, 63, 63, 63, 63, 63, 
	63, 63, 63, 63, 63, 63, 63, 63, 
	63, 63, 63, 63, 63, 63, 63, 63, 
	63, 63, 63, 63, 63, 63, 63, 63, 
	63, 63, 63, 63, 63, 63, 63, 58, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	58, 65, 65, 65, 65, 65, 65, 65, 
	65, 65, 65, 58, 58, 58, 58, 58, 
	58, 58, 65, 65, 65, 65, 65, 65, 
	65, 65, 65, 65, 65, 65, 65, 65, 
	65, 65, 65, 65, 65, 65, 65, 65, 
	65, 65, 65, 65, 58, 58, 58, 58, 
	58, 58, 65, 65, 65, 65, 65, 65, 
	65, 65, 65, 65, 65, 65, 65, 65, 
	65, 65, 65, 65, 65, 65, 65, 65, 
	65, 65, 65, 65, 58, 68, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 68, 68, 68, 68, 68, 68, 68, 
	68, 68, 68, 68, 68, 68, 68, 68, 
	68, 68, 68, 68, 68, 68, 68, 68, 
	68, 68, 68, 67, 67, 67, 67, 67, 
	67, 68, 68, 68, 68, 68, 68, 68, 
	68, 68, 68, 68, 68, 68, 68, 68, 
	68, 68, 68, 68, 68, 68, 68, 68, 
	68, 68, 68, 67, 68, 69, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	68, 68, 68, 68, 68, 68, 68, 68, 
	68, 68, 68, 68, 68, 68, 68, 68, 
	68, 68, 68, 68, 68, 68, 68, 68, 
	68, 68, 67, 67, 67, 67, 67, 67, 
	68, 68, 68, 68, 68, 68, 68, 68, 
	68, 68, 68, 68, 68, 68, 68, 68, 
	68, 68, 68, 68, 68, 68, 68, 68, 
	68, 68, 67, 70, 67, 71, 67, 67, 
	72, 73, 74, 75, 67, 67, 76, 67, 
	67, 67, 67, 77, 67, 67, 67, 78, 
	67, 67, 79, 67, 80, 67, 81, 82, 
	67, 72, 73, 74, 75, 67, 67, 76, 
	67, 67, 67, 67, 77, 67, 67, 67, 
	78, 67, 67, 79, 67, 80, 67, 81, 
	82, 67, 83, 67, 67, 67, 67, 67, 
	67, 84, 67, 85, 67, 86, 67, 87, 
	67, 88, 67, 89, 67, 90, 67, 91, 
	67, 88, 67, 92, 67, 93, 67, 88, 
	67, 94, 67, 95, 67, 96, 67, 88, 
	67, 97, 67, 98, 67, 99, 67, 88, 
	67, 100, 67, 101, 67, 102, 67, 88, 
	67, 103, 67, 104, 67, 105, 67, 88, 
	67, 106, 67, 107, 67, 108, 67, 88, 
	67, 109, 67, 67, 110, 67, 111, 67, 
	102, 67, 112, 67, 102, 67, 113, 67, 
	114, 67, 115, 67, 88, 67, 116, 67, 
	107, 67, 117, 67, 118, 67, 88, 67, 
	75, 67, 119, 119, 119, 119, 119, 119, 
	119, 119, 119, 119, 119, 119, 119, 119, 
	119, 119, 119, 119, 119, 119, 119, 119, 
	119, 119, 119, 119, 67, 67, 67, 67, 
	67, 67, 119, 119, 119, 119, 119, 119, 
	119, 119, 119, 119, 119, 119, 119, 119, 
	119, 119, 119, 119, 119, 119, 119, 119, 
	119, 119, 119, 119, 67, 120, 67, 121, 
	67, 123, 123, 123, 123, 123, 123, 123, 
	123, 123, 123, 123, 123, 123, 123, 123, 
	123, 123, 123, 123, 123, 123, 123, 123, 
	123, 123, 123, 123, 123, 123, 123, 123, 
	123, 123, 123, 123, 123, 123, 123, 123, 
	123, 123, 123, 123, 123, 123, 123, 123, 
	123, 123, 123, 123, 123, 123, 123, 123, 
	123, 123, 123, 123, 123, 123, 123, 123, 
	123, 122, 124, 124, 124, 124, 124, 124, 
	124, 124, 124, 124, 124, 124, 124, 124, 
	124, 124, 124, 124, 124, 124, 124, 124, 
	124, 124, 124, 124, 124, 124, 124, 124, 
	124, 124, 124, 124, 124, 124, 124, 124, 
	124, 124, 124, 124, 124, 124, 124, 124, 
	124, 124, 124, 124, 124, 124, 124, 124, 
	124, 124, 124, 124, 124, 124, 124, 124, 
	124, 124, 122, 125, 125, 125, 125, 125, 
	125, 125, 125, 125, 125, 125, 125, 125, 
	125, 125, 125, 125, 125, 125, 125, 125, 
	125, 125, 125, 125, 125, 125, 125, 125, 
	125, 125, 125, 125, 125, 125, 125, 125, 
	125, 125, 125, 125, 125, 125, 125, 125, 
	125, 125, 125, 125, 125, 125, 125, 125, 
	125, 125, 125, 125, 125, 125, 125, 125, 
	125, 125, 125, 122, 126, 126, 126, 126, 
	126, 126, 126, 126, 126, 126, 126, 126, 
	126, 126, 126, 126, 126, 126, 126, 126, 
	126, 126, 126, 126, 126, 126, 126, 126, 
	126, 126, 126, 126, 126, 126, 126, 126, 
	126, 126, 126, 126, 126, 126, 126, 126, 
	126, 126, 126, 126, 126, 126, 126, 126, 
	126, 126, 126, 126, 126, 126, 126, 126, 
	126, 126, 126, 126, 122, 127, 127, 127, 
	127, 127, 127, 127, 127, 127, 127, 127, 
	127, 127, 127, 127, 127, 127, 127, 127, 
	127, 127, 127, 127, 127, 127, 127, 127, 
	127, 127, 127, 127, 127, 127, 127, 127, 
	127, 127, 127, 127, 127, 127, 127, 127, 
	127, 127, 127, 127, 127, 127, 127, 127, 
	127, 127, 127, 127, 127, 127, 127, 127, 
	127, 127, 127, 127, 127, 122, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 122, 130, 
	129, 131, 129, 132, 132, 132, 132, 132, 
	132, 132, 132, 132, 132, 129, 129, 129, 
	129, 129, 129, 129, 132, 132, 132, 132, 
	132, 132, 129, 129, 129, 129, 129, 129, 
	129, 129, 129, 129, 129, 129, 129, 129, 
	129, 129, 129, 129, 129, 129, 129, 129, 
	129, 129, 129, 129, 132, 132, 132, 132, 
	132, 132, 129, 133, 39, 136, 135, 137, 
	135, 138, 39, 141, 140, 140, 140, 140, 
	140, 140, 140, 140, 140, 140, 140, 140, 
	140, 140, 140, 140, 140, 140, 140, 140, 
	140, 140, 140, 140, 140, 140, 140, 140, 
	140, 140, 140, 142, 140, 142, 140, 143, 
	140, 144, 140, 145, 145, 145, 145, 145, 
	145, 145, 145, 145, 145, 39, 39, 39, 
	39, 39, 39, 39, 145, 145, 145, 145, 
	145, 145, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 145, 145, 145, 145, 
	145, 145, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 146, 39, 
	147, 147, 147, 147, 147, 147, 147, 147, 
	147, 147, 39, 39, 39, 39, 39, 39, 
	39, 147, 147, 147, 147, 147, 147, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 147, 147, 147, 147, 147, 147, 39, 
	148, 148, 148, 148, 148, 148, 148, 148, 
	148, 148, 39, 39, 39, 39, 39, 39, 
	39, 148, 148, 148, 148, 148, 148, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 148, 148, 148, 148, 148, 148, 39, 
	149, 149, 149, 149, 149, 149, 149, 149, 
	149, 149, 39, 39, 39, 39, 39, 39, 
	39, 149, 149, 149, 149, 149, 149, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 149, 149, 149, 149, 149, 149, 39, 
	150, 150, 150, 150, 150, 150, 150, 150, 
	150, 150, 39, 39, 39, 39, 39, 39, 
	39, 150, 150, 150, 150, 150, 150, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 150, 150, 150, 150, 150, 150, 39, 
	146, 146, 146, 146, 146, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 146, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 151, 
	151, 151, 151, 151, 151, 151, 151, 151, 
	151, 39, 39, 39, 39, 39, 39, 39, 
	151, 151, 151, 151, 151, 151, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	151, 151, 151, 151, 151, 151, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 149, 39, 146, 146, 
	146, 146, 146, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 146, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 152, 152, 152, 
	152, 152, 152, 152, 152, 152, 152, 39, 
	39, 39, 39, 39, 39, 39, 152, 152, 
	152, 152, 152, 152, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 152, 152, 
	152, 152, 152, 152, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 149, 39, 146, 146, 146, 146, 
	146, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 146, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 153, 153, 153, 153, 153, 
	153, 153, 153, 153, 153, 39, 39, 39, 
	39, 39, 39, 39, 153, 153, 153, 153, 
	153, 153, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 153, 153, 153, 153, 
	153, 153, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	149, 39, 146, 146, 146, 146, 146, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 146, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 154, 154, 154, 154, 154, 154, 154, 
	154, 154, 154, 39, 39, 39, 39, 39, 
	39, 39, 154, 154, 154, 154, 154, 154, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 154, 154, 154, 154, 154, 154, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 149, 39, 
	146, 146, 146, 146, 146, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 146, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 149, 39, 156, 156, 
	156, 156, 156, 156, 156, 156, 156, 156, 
	155, 155, 155, 155, 155, 155, 155, 156, 
	156, 156, 156, 156, 156, 155, 155, 155, 
	155, 155, 155, 155, 155, 155, 155, 155, 
	155, 155, 155, 155, 155, 155, 155, 155, 
	155, 155, 155, 155, 155, 155, 155, 156, 
	156, 156, 156, 156, 156, 155, 155, 155, 
	155, 155, 155, 155, 155, 155, 155, 155, 
	155, 155, 155, 155, 155, 155, 155, 155, 
	155, 157, 155, 159, 159, 159, 159, 159, 
	158, 158, 158, 158, 158, 158, 158, 158, 
	158, 158, 158, 158, 158, 158, 158, 158, 
	158, 158, 159, 158, 158, 158, 158, 158, 
	158, 158, 158, 158, 158, 158, 158, 158, 
	158, 158, 160, 160, 160, 160, 160, 160, 
	160, 160, 160, 160, 158, 158, 158, 158, 
	158, 158, 158, 160, 160, 160, 160, 160, 
	160, 158, 158, 158, 158, 158, 158, 158, 
	158, 158, 158, 158, 158, 158, 158, 158, 
	158, 158, 158, 158, 158, 158, 158, 158, 
	158, 158, 158, 160, 160, 160, 160, 160, 
	160, 158, 158, 158, 158, 158, 158, 158, 
	158, 158, 158, 158, 158, 158, 158, 158, 
	158, 158, 158, 158, 158, 158, 158, 161, 
	158, 163, 163, 163, 163, 163, 162, 162, 
	162, 162, 162, 162, 162, 162, 162, 162, 
	162, 162, 162, 162, 162, 162, 162, 162, 
	163, 162, 162, 162, 162, 162, 162, 162, 
	162, 162, 162, 162, 162, 162, 162, 162, 
	162, 162, 162, 162, 162, 162, 162, 162, 
	162, 162, 162, 162, 162, 162, 162, 162, 
	162, 162, 162, 162, 162, 162, 162, 162, 
	162, 162, 162, 162, 162, 162, 162, 162, 
	162, 162, 162, 162, 162, 162, 162, 162, 
	162, 162, 162, 162, 162, 162, 162, 162, 
	162, 162, 162, 162, 162, 162, 162, 162, 
	162, 162, 162, 162, 162, 162, 162, 162, 
	162, 162, 162, 162, 162, 162, 162, 162, 
	162, 162, 162, 162, 162, 161, 162, 165, 
	164, 166, 164, 164, 164, 164, 164, 164, 
	164, 164, 167, 167, 167, 167, 167, 167, 
	167, 167, 167, 167, 164, 164, 164, 164, 
	164, 164, 164, 167, 167, 167, 167, 167, 
	167, 167, 167, 167, 167, 167, 167, 167, 
	167, 167, 167, 167, 167, 167, 167, 167, 
	167, 167, 167, 167, 167, 164, 164, 164, 
	164, 167, 164, 167, 167, 167, 167, 167, 
	167, 167, 167, 167, 167, 167, 167, 167, 
	167, 167, 167, 167, 167, 167, 167, 167, 
	167, 167, 167, 167, 167, 164, 165, 164, 
	164, 164, 164, 164, 164, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 164, 
	169, 169, 169, 169, 169, 169, 169, 169, 
	169, 169, 164, 164, 164, 164, 166, 164, 
	164, 169, 169, 169, 169, 169, 169, 169, 
	169, 169, 169, 169, 169, 169, 169, 169, 
	169, 169, 169, 169, 169, 169, 169, 169, 
	169, 169, 169, 164, 164, 164, 164, 169, 
	164, 169, 169, 169, 169, 169, 169, 169, 
	169, 169, 169, 169, 169, 169, 169, 169, 
	169, 169, 169, 169, 169, 169, 169, 169, 
	169, 169, 169, 164, 170, 170, 170, 170, 
	170, 170, 170, 170, 170, 170, 170, 170, 
	170, 170, 170, 170, 170, 170, 170, 170, 
	170, 170, 170, 170, 170, 170, 170, 170, 
	170, 170, 171, 171, 171, 171, 171, 171, 
	171, 171, 171, 171, 171, 171, 171, 171, 
	171, 171, 172, 172, 172, 172, 172, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 
	34, 34, 34, 173, 173, 173, 173, 173, 
	173, 173, 173, 174, 174, 174, 174, 174, 
	173, 173, 173, 173, 173, 173, 173, 173, 
	173, 173, 173, 173, 173, 173, 173, 173, 
	173, 173, 175, 176, 176, 177, 178, 176, 
	176, 176, 179, 180, 181, 182, 176, 176, 
	183, 176, 176, 176, 176, 176, 176, 176, 
	176, 176, 176, 176, 176, 176, 176, 176, 
	176, 184, 176, 176, 176, 176, 176, 176, 
	176, 176, 176, 176, 176, 176, 176, 176, 
	176, 176, 176, 176, 176, 176, 176, 176, 
	176, 176, 176, 176, 176, 185, 186, 34, 
	187, 176, 176, 176, 176, 176, 176, 176, 
	176, 176, 176, 176, 176, 176, 176, 176, 
	176, 176, 176, 176, 176, 176, 176, 176, 
	176, 176, 176, 176, 176, 36, 188, 34, 
	176, 173, 34, 170, 170, 170, 170, 170, 
	170, 170, 170, 170, 170, 170, 170, 170, 
	170, 170, 170, 170, 170, 170, 170, 170, 
	170, 170, 170, 170, 170, 170, 170, 170, 
	170, 189, 171, 171, 171, 171, 171, 171, 
	171, 171, 171, 171, 171, 171, 171, 171, 
	171, 171, 189, 172, 172, 172, 172, 172, 
	189, 173, 173, 173, 173, 173, 173, 173, 
	173, 173, 173, 173, 173, 173, 173, 173, 
	173, 173, 173, 173, 173, 173, 173, 173, 
	173, 173, 173, 173, 173, 173, 173, 173, 
	189, 189, 189, 189, 189, 189, 189, 189, 
	189, 189, 189, 189, 189, 189, 189, 189, 
	189, 189, 189, 189, 189, 189, 189, 189, 
	189, 189, 189, 189, 189, 189, 189, 189, 
	189, 189, 189, 189, 189, 189, 189, 189, 
	189, 189, 189, 189, 189, 189, 189, 189, 
	189, 189, 189, 189, 189, 189, 189, 189, 
	189, 189, 189, 189, 189, 189, 189, 189, 
	189, 189, 189, 189, 189, 189, 189, 189, 
	189, 189, 189, 189, 189, 189, 189, 189, 
	189, 189, 189, 189, 189, 189, 189, 189, 
	189, 189, 189, 189, 189, 189, 189, 173, 
	189, 173, 173, 173, 173, 173, 173, 173, 
	173, 174, 174, 174, 174, 174, 173, 173, 
	173, 173, 173, 173, 173, 173, 173, 173, 
	173, 173, 173, 173, 173, 173, 173, 173, 
	175, 190, 190, 190, 190, 190, 190, 190, 
	190, 190, 190, 190, 190, 190, 190, 190, 
	190, 190, 190, 190, 190, 190, 190, 190, 
	190, 190, 190, 190, 190, 190, 190, 190, 
	190, 190, 190, 190, 190, 190, 190, 190, 
	190, 190, 190, 190, 190, 190, 190, 190, 
	190, 190, 190, 190, 190, 190, 190, 190, 
	190, 190, 190, 190, 190, 190, 190, 190, 
	190, 190, 190, 190, 190, 190, 190, 190, 
	190, 190, 190, 190, 190, 190, 190, 190, 
	190, 190, 190, 190, 190, 190, 190, 190, 
	190, 190, 190, 190, 190, 190, 190, 173, 
	190, 175, 175, 175, 175, 175, 190, 190, 
	190, 190, 190, 190, 190, 190, 190, 190, 
	190, 190, 190, 190, 190, 190, 190, 190, 
	175, 190, 176, 176, 176, 189, 176, 176, 
	176, 189, 189, 189, 189, 176, 176, 189, 
	176, 176, 176, 176, 176, 176, 176, 176, 
	176, 176, 176, 176, 176, 176, 176, 176, 
	189, 176, 176, 176, 176, 176, 176, 176, 
	176, 176, 176, 176, 176, 176, 176, 176, 
	176, 176, 176, 176, 176, 176, 176, 176, 
	176, 176, 176, 176, 189, 189, 189, 189, 
	176, 176, 176, 176, 176, 176, 176, 176, 
	176, 176, 176, 176, 176, 176, 176, 176, 
	176, 176, 176, 176, 176, 176, 176, 176, 
	176, 176, 176, 176, 189, 189, 189, 176, 
	189, 9, 8, 8, 8, 8, 8, 8, 
	8, 8, 8, 8, 8, 8, 8, 8, 
	8, 8, 8, 8, 8, 8, 8, 8, 
	177, 177, 177, 8, 177, 177, 177, 8, 
	8, 8, 8, 177, 177, 8, 177, 177, 
	177, 177, 177, 177, 177, 177, 177, 177, 
	177, 177, 177, 177, 177, 177, 8, 177, 
	177, 177, 177, 177, 177, 177, 177, 177, 
	177, 177, 177, 177, 177, 177, 177, 177, 
	177, 177, 177, 177, 177, 177, 177, 177, 
	177, 177, 8, 8, 8, 8, 177, 177, 
	177, 177, 177, 177, 177, 177, 177, 177, 
	177, 177, 177, 177, 177, 177, 177, 177, 
	177, 177, 177, 177, 177, 177, 177, 177, 
	177, 177, 8, 8, 8, 177, 8, 192, 
	191, 194, 193, 193, 193, 193, 193, 193, 
	193, 193, 193, 193, 193, 193, 193, 193, 
	193, 193, 193, 193, 193, 194, 193, 196, 
	195, 195, 195, 195, 195, 195, 195, 195, 
	195, 195, 195, 195, 195, 195, 195, 195, 
	195, 195, 195, 196, 195, 198, 197, 197, 
	197, 197, 197, 197, 197, 197, 197, 197, 
	197, 197, 197, 197, 197, 197, 197, 197, 
	197, 198, 197, 200, 200, 199, 201, 199, 
	199, 200, 201, 199, 199, 202, 199, 199, 
	199, 199, 199, 199, 201, 201, 199, 199, 
	199, 201, 201, 199, 200, 199, 199, 199, 
	199, 199, 199, 199, 200, 199, 201, 199, 
	199, 203, 201, 199, 199, 203, 199, 199, 
	199, 199, 199, 199, 199, 201, 199, 199, 
	199, 201, 199, 199, 200, 199, 205, 204, 
	204, 204, 204, 204, 204, 204, 204, 204, 
	204, 204, 204, 204, 204, 204, 204, 204, 
	204, 204, 205, 204, 206, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 206, 39, 208, 208, 
	208, 208, 208, 208, 208, 208, 208, 208, 
	208, 208, 208, 208, 208, 208, 208, 208, 
	208, 208, 208, 208, 208, 208, 208, 208, 
	208, 208, 208, 208, 209, 209, 209, 209, 
	209, 209, 209, 209, 209, 209, 209, 209, 
	209, 209, 209, 209, 210, 210, 210, 210, 
	210, 207, 207, 207, 207, 207, 207, 207, 
	207, 207, 207, 207, 207, 211, 211, 211, 
	211, 211, 211, 211, 211, 211, 211, 211, 
	211, 211, 211, 211, 211, 211, 211, 211, 
	211, 211, 211, 211, 211, 211, 211, 211, 
	211, 211, 211, 211, 207, 207, 207, 207, 
	212, 207, 213, 207, 212, 212, 212, 212, 
	207, 214, 212, 207, 215, 215, 215, 215, 
	215, 215, 215, 215, 215, 215, 207, 207, 
	207, 207, 207, 212, 207, 215, 215, 215, 
	215, 215, 215, 215, 215, 215, 215, 215, 
	215, 215, 215, 215, 215, 215, 215, 215, 
	215, 215, 215, 215, 215, 215, 215, 216, 
	217, 218, 219, 207, 207, 215, 215, 215, 
	215, 215, 215, 215, 215, 215, 215, 215, 
	215, 215, 215, 215, 215, 215, 215, 215, 
	215, 215, 215, 215, 215, 215, 215, 212, 
	212, 212, 207, 211, 207, 59, 59, 59, 
	59, 59, 59, 59, 59, 59, 59, 59, 
	59, 59, 59, 59, 59, 59, 59, 59, 
	59, 59, 59, 59, 59, 59, 59, 59, 
	59, 59, 59, 59, 59, 59, 59, 59, 
	59, 59, 59, 59, 59, 59, 59, 59, 
	59, 59, 59, 59, 59, 59, 59, 59, 
	59, 59, 59, 59, 59, 59, 59, 59, 
	59, 59, 59, 59, 59, 220, 221, 221, 
	221, 221, 221, 221, 221, 221, 221, 221, 
	221, 221, 221, 221, 221, 221, 221, 221, 
	221, 221, 221, 221, 221, 221, 221, 221, 
	221, 221, 221, 221, 220, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 61, 61, 61, 
	61, 61, 61, 61, 61, 220, 222, 222, 
	222, 222, 222, 222, 222, 222, 222, 222, 
	222, 222, 222, 222, 222, 222, 220, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 64, 64, 
	64, 64, 64, 64, 64, 64, 64, 220, 
	223, 223, 223, 223, 223, 220, 211, 211, 
	211, 211, 211, 211, 211, 211, 211, 211, 
	211, 211, 211, 211, 211, 211, 211, 211, 
	211, 211, 211, 211, 211, 211, 211, 211, 
	211, 211, 211, 211, 211, 220, 220, 220, 
	220, 220, 220, 220, 220, 220, 220, 220, 
	220, 220, 220, 220, 220, 220, 220, 220, 
	220, 220, 220, 220, 220, 220, 220, 220, 
	220, 220, 220, 220, 220, 220, 220, 220, 
	220, 220, 220, 220, 220, 220, 220, 220, 
	220, 220, 220, 220, 220, 220, 220, 220, 
	220, 220, 220, 220, 220, 220, 220, 220, 
	220, 220, 220, 220, 220, 220, 220, 220, 
	220, 220, 220, 220, 220, 220, 220, 220, 
	220, 220, 220, 220, 220, 220, 220, 220, 
	220, 220, 220, 220, 220, 220, 220, 220, 
	220, 220, 220, 220, 211, 220, 224, 220, 
	225, 220, 226, 220, 229, 228, 228, 228, 
	228, 228, 228, 228, 228, 228, 228, 228, 
	230, 228, 228, 231, 228, 232, 232, 232, 
	232, 232, 232, 232, 232, 232, 232, 232, 
	232, 232, 232, 232, 232, 232, 232, 232, 
	232, 232, 232, 232, 232, 232, 232, 232, 
	232, 232, 232, 233, 233, 233, 233, 233, 
	233, 233, 233, 233, 233, 233, 233, 233, 
	233, 233, 233, 234, 234, 234, 234, 234, 
	39, 39, 39, 39, 39, 39, 39, 39, 
	39, 39, 39, 39, 235, 235, 235, 235, 
	235, 235, 235, 235, 235, 235, 235, 235, 
	235, 235, 235, 235, 235, 235, 235, 235, 
	235, 235, 235, 235, 235, 235, 235, 235, 
	235, 235, 235, 236, 236, 236, 236, 237, 
	236, 236, 236, 237, 237, 237, 237, 238, 
	237, 237, 236, 236, 236, 236, 236, 236, 
	236, 236, 236, 236, 236, 236, 236, 236, 
	236, 236, 237, 236, 236, 236, 236, 239, 
	236, 236, 236, 239, 236, 236, 236, 236, 
	236, 236, 236, 240, 236, 239, 239, 236, 
	236, 236, 239, 239, 236, 236, 237, 237, 
	237, 237, 236, 236, 236, 241, 236, 239, 
	236, 236, 236, 239, 236, 236, 236, 236, 
	236, 236, 236, 240, 236, 236, 239, 236, 
	236, 236, 239, 242, 236, 236, 237, 237, 
	237, 236, 235, 39, 232, 232, 232, 232, 
	232, 232, 232, 232, 232, 232, 232, 232, 
	232, 232, 232, 232, 232, 232, 232, 232, 
	232, 232, 232, 232, 232, 232, 232, 232, 
	232, 232, 243, 233, 233, 233, 233, 233, 
	233, 233, 233, 233, 233, 233, 233, 233, 
	233, 233, 233, 243, 234, 234, 234, 234, 
	234, 243, 235, 235, 235, 235, 235, 235, 
	235, 235, 235, 235, 235, 235, 235, 235, 
	235, 235, 235, 235, 235, 235, 235, 235, 
	235, 235, 235, 235, 235, 235, 235, 235, 
	235, 243, 243, 243, 243, 243, 243, 243, 
	243, 243, 243, 243, 243, 243, 243, 243, 
	243, 243, 243, 243, 243, 243, 243, 243, 
	243, 243, 243, 243, 243, 243, 243, 243, 
	243, 243, 243, 243, 243, 243, 243, 243, 
	243, 243, 243, 243, 243, 243, 243, 243, 
	243, 243, 243, 243, 243, 243, 243, 243, 
	243, 243, 243, 243, 243, 243, 243, 243, 
	243, 243, 243, 243, 243, 243, 243, 243, 
	243, 243, 243, 243, 243, 243, 243, 243, 
	243, 243, 243, 243, 243, 243, 243, 243, 
	243, 243, 243, 243, 243, 243, 243, 243, 
	235, 243, 236, 236, 236, 236, 122, 236, 
	236, 236, 122, 122, 122, 122, 236, 122, 
	122, 236, 236, 236, 236, 236, 236, 236, 
	236, 236, 236, 236, 236, 236, 236, 236, 
	236, 122, 236, 236, 236, 236, 236, 236, 
	236, 236, 236, 236, 236, 236, 236, 236, 
	236, 236, 236, 236, 236, 236, 236, 236, 
	236, 236, 236, 236, 236, 122, 122, 122, 
	122, 236, 236, 236, 236, 236, 236, 236, 
	236, 236, 236, 236, 236, 236, 236, 236, 
	236, 236, 236, 236, 236, 236, 236, 236, 
	236, 236, 236, 236, 236, 122, 122, 122, 
	236, 122, 236, 236, 236, 236, 243, 236, 
	236, 236, 243, 243, 243, 243, 236, 243, 
	243, 236, 244, 244, 244, 244, 244, 244, 
	244, 244, 244, 244, 236, 236, 236, 236, 
	236, 243, 236, 244, 244, 244, 244, 244, 
	244, 236, 236, 236, 236, 236, 236, 236, 
	236, 236, 236, 236, 236, 236, 236, 236, 
	236, 236, 236, 236, 236, 243, 243, 243, 
	243, 236, 236, 244, 244, 244, 244, 244, 
	244, 236, 236, 236, 236, 236, 236, 236, 
	236, 236, 236, 236, 236, 236, 236, 236, 
	236, 236, 236, 236, 236, 243, 243, 243, 
	236, 243, 236, 236, 236, 236, 245, 236, 
	236, 236, 245, 245, 245, 245, 236, 246, 
	245, 236, 247, 247, 247, 247, 247, 247, 
	247, 247, 247, 247, 236, 236, 236, 236, 
	236, 245, 236, 247, 247, 247, 247, 247, 
	247, 236, 236, 236, 236, 236, 236, 236, 
	236, 236, 236, 236, 236, 236, 236, 236, 
	236, 236, 236, 236, 236, 245, 245, 245, 
	245, 236, 236, 247, 247, 247, 247, 247, 
	247, 236, 236, 236, 236, 236, 236, 236, 
	236, 236, 236, 236, 236, 236, 236, 236, 
	236, 236, 236, 236, 236, 245, 245, 245, 
	236, 245, 249, 249, 249, 249, 249, 249, 
	249, 249, 249, 249, 248, 248, 248, 248, 
	248, 248, 248, 249, 249, 249, 249, 249, 
	249, 248, 248, 248, 248, 248, 248, 248, 
	248, 248, 248, 248, 248, 248, 248, 248, 
	248, 248, 248, 248, 248, 248, 248, 248, 
	248, 248, 248, 249, 249, 249, 249, 249, 
	249, 248, 236, 236, 236, 236, 245, 236, 
	236, 236, 245, 245, 245, 245, 236, 246, 
	245, 236, 236, 236, 236, 236, 236, 236, 
	236, 236, 236, 236, 236, 236, 236, 236, 
	236, 245, 236, 236, 236, 236, 236, 236, 
	236, 236, 236, 236, 236, 236, 236, 236, 
	236, 236, 236, 236, 236, 236, 236, 236, 
	236, 236, 236, 236, 236, 245, 245, 245, 
	245, 236, 236, 236, 236, 236, 236, 236, 
	236, 236, 236, 236, 236, 236, 236, 236, 
	236, 236, 236, 236, 236, 236, 236, 236, 
	236, 236, 236, 236, 236, 245, 245, 245, 
	236, 245, 251, 250, 250, 250, 251, 251, 
	251, 251, 250, 250, 251, 250, 252, 253, 
	253, 253, 253, 253, 253, 253, 254, 254, 
	250, 250, 250, 250, 250, 251, 250, 39, 
	39, 255, 39, 250, 250, 39, 39, 250, 
	250, 250, 250, 256, 250, 250, 257, 250, 
	39, 39, 250, 250, 250, 39, 39, 250, 
	39, 251, 251, 251, 251, 250, 250, 258, 
	258, 133, 39, 258, 258, 39, 39, 250, 
	250, 39, 250, 250, 258, 250, 257, 250, 
	258, 258, 258, 259, 258, 39, 260, 250, 
	39, 251, 251, 251, 250, 262, 262, 262, 
	262, 262, 262, 262, 262, 261, 264, 264, 
	264, 264, 264, 264, 264, 264, 263, 267, 
	266, 270, 269, 271, 269, 274, 274, 274, 
	274, 274, 274, 274, 274, 274, 274, 273, 
	273, 273, 273, 273, 273, 273, 274, 274, 
	274, 274, 274, 274, 273, 273, 273, 273, 
	273, 273, 273, 273, 273, 273, 273, 273, 
	273, 273, 273, 273, 273, 273, 273, 273, 
	273, 273, 273, 273, 273, 273, 274, 274, 
	274, 274, 274, 274, 273, 275, 276, 275, 
	277, 275, 278, 275, 279, 275, 280, 275, 
	281, 275, 282, 275, 161, 283, 283, 283, 
	283, 283, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 283, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 161, 276, 284, 284, 284, 284, 284, 
	277, 277, 277, 277, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 277, 277, 277, 
	277, 277, 284, 277, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 277, 277, 161, 
	277, 285, 285, 285, 285, 285, 278, 278, 
	278, 278, 278, 278, 278, 278, 278, 278, 
	278, 278, 278, 278, 278, 278, 278, 278, 
	285, 278, 278, 278, 278, 278, 278, 278, 
	278, 278, 278, 278, 278, 278, 278, 278, 
	278, 278, 278, 278, 278, 278, 278, 278, 
	278, 278, 278, 278, 278, 278, 278, 278, 
	278, 278, 278, 278, 278, 278, 278, 278, 
	278, 278, 278, 278, 278, 278, 278, 278, 
	278, 278, 278, 278, 278, 278, 278, 278, 
	278, 278, 278, 278, 278, 278, 278, 278, 
	278, 278, 278, 278, 278, 278, 278, 278, 
	278, 278, 278, 278, 278, 278, 278, 278, 
	278, 278, 278, 278, 278, 278, 278, 278, 
	278, 278, 278, 278, 278, 161, 278, 286, 
	286, 286, 286, 286, 279, 279, 279, 279, 
	279, 279, 279, 279, 279, 279, 279, 279, 
	279, 279, 279, 279, 279, 279, 286, 279, 
	279, 279, 279, 279, 279, 279, 279, 279, 
	279, 279, 279, 279, 279, 279, 279, 279, 
	279, 279, 279, 279, 279, 279, 279, 279, 
	279, 279, 279, 279, 279, 279, 279, 279, 
	279, 279, 279, 279, 279, 279, 279, 279, 
	279, 279, 279, 279, 279, 279, 279, 279, 
	279, 279, 279, 279, 279, 279, 279, 279, 
	279, 279, 279, 279, 279, 279, 279, 279, 
	279, 279, 279, 279, 279, 279, 279, 279, 
	279, 279, 279, 279, 279, 279, 279, 279, 
	279, 279, 279, 279, 279, 279, 279, 279, 
	279, 279, 279, 161, 279, 287, 287, 287, 
	287, 287, 280, 280, 280, 280, 280, 280, 
	280, 280, 280, 280, 280, 280, 280, 280, 
	280, 280, 280, 280, 287, 280, 280, 280, 
	280, 280, 280, 280, 280, 280, 280, 280, 
	280, 280, 280, 280, 280, 280, 280, 280, 
	280, 280, 280, 280, 280, 280, 280, 280, 
	280, 280, 280, 280, 280, 280, 280, 280, 
	280, 280, 280, 280, 280, 280, 280, 280, 
	280, 280, 280, 280, 280, 280, 280, 280, 
	280, 280, 280, 280, 280, 280, 280, 280, 
	280, 280, 280, 280, 280, 280, 280, 280, 
	280, 280, 280, 280, 280, 280, 280, 280, 
	280, 280, 280, 280, 280, 280, 280, 280, 
	280, 280, 280, 280, 280, 280, 280, 280, 
	280, 161, 280, 288, 288, 288, 288, 288, 
	281, 281, 281, 281, 281, 281, 281, 281, 
	281, 281, 281, 281, 281, 281, 281, 281, 
	281, 281, 288, 281, 281, 281, 281, 281, 
	281, 281, 281, 281, 281, 281, 281, 281, 
	281, 281, 281, 281, 281, 281, 281, 281, 
	281, 281, 281, 281, 281, 281, 281, 281, 
	281, 281, 281, 281, 281, 281, 281, 281, 
	281, 281, 281, 281, 281, 281, 281, 281, 
	281, 281, 281, 281, 281, 281, 281, 281, 
	281, 281, 281, 281, 281, 281, 281, 281, 
	281, 281, 281, 281, 281, 281, 281, 281, 
	281, 281, 281, 281, 281, 281, 281, 281, 
	281, 281, 281, 281, 281, 281, 281, 281, 
	281, 281, 281, 281, 281, 281, 281, 161, 
	281, 289, 289, 289, 289, 289, 282, 282, 
	282, 282, 282, 282, 282, 282, 282, 282, 
	282, 282, 282, 282, 282, 282, 282, 282, 
	289, 282, 282, 282, 282, 282, 282, 282, 
	282, 282, 282, 282, 282, 282, 282, 282, 
	282, 282, 282, 282, 282, 282, 282, 282, 
	282, 282, 282, 282, 282, 282, 282, 282, 
	282, 282, 282, 282, 282, 282, 282, 282, 
	282, 282, 282, 282, 282, 282, 282, 282, 
	282, 282, 282, 282, 282, 282, 282, 282, 
	282, 282, 282, 282, 282, 282, 282, 282, 
	282, 282, 282, 282, 282, 282, 282, 282, 
	282, 282, 282, 282, 282, 282, 282, 282, 
	282, 282, 282, 282, 282, 282, 282, 282, 
	282, 282, 282, 282, 282, 161, 282, 290, 
	290, 290, 290, 290, 161, 161, 161, 161, 
	161, 161, 161, 161, 161, 161, 161, 161, 
	161, 161, 161, 161, 161, 161, 290, 161, 
	163, 163, 163, 163, 163, 275, 275, 275, 
	275, 275, 275, 275, 275, 275, 275, 275, 
	275, 275, 275, 275, 275, 275, 275, 163, 
	275, 275, 275, 275, 275, 275, 275, 275, 
	275, 275, 275, 275, 275, 275, 275, 275, 
	275, 275, 275, 275, 275, 275, 275, 275, 
	275, 275, 275, 275, 275, 275, 275, 275, 
	275, 275, 275, 275, 275, 275, 275, 275, 
	275, 275, 275, 275, 275, 275, 275, 275, 
	275, 275, 275, 275, 275, 275, 275, 275, 
	275, 275, 275, 275, 275, 275, 275, 275, 
	275, 275, 275, 275, 275, 275, 275, 275, 
	275, 275, 275, 275, 275, 275, 275, 275, 
	275, 275, 275, 275, 275, 275, 275, 275, 
	275, 275, 275, 275, 161, 275, 292, 292, 
	292, 292, 292, 292, 292, 292, 292, 292, 
	276, 276, 276, 276, 276, 276, 276, 292, 
	292, 292, 292, 292, 292, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 292, 
	292, 292, 292, 292, 292, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 293, 276, 294, 294, 294, 
	294, 294, 294, 294, 294, 294, 294, 277, 
	277, 277, 277, 277, 277, 277, 294, 294, 
	294, 294, 294, 294, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 277, 294, 294, 
	294, 294, 294, 294, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 277, 277, 277, 
	277, 277, 277, 277, 277, 277, 277, 277, 
	277, 277, 293, 277, 295, 295, 295, 295, 
	295, 295, 295, 295, 295, 295, 278, 278, 
	278, 278, 278, 278, 278, 295, 295, 295, 
	295, 295, 295, 278, 278, 278, 278, 278, 
	278, 278, 278, 278, 278, 278, 278, 278, 
	278, 278, 278, 278, 278, 278, 278, 278, 
	278, 278, 278, 278, 278, 295, 295, 295, 
	295, 295, 295, 278, 278, 278, 278, 278, 
	278, 278, 278, 278, 278, 278, 278, 278, 
	278, 278, 278, 278, 278, 278, 278, 278, 
	278, 293, 278, 296, 296, 296, 296, 296, 
	296, 296, 296, 296, 296, 279, 279, 279, 
	279, 279, 279, 279, 296, 296, 296, 296, 
	296, 296, 279, 279, 279, 279, 279, 279, 
	279, 279, 279, 279, 279, 279, 279, 279, 
	279, 279, 279, 279, 279, 279, 279, 279, 
	279, 279, 279, 279, 296, 296, 296, 296, 
	296, 296, 279, 279, 279, 279, 279, 279, 
	279, 279, 279, 279, 279, 279, 279, 279, 
	279, 279, 279, 279, 279, 279, 279, 279, 
	293, 279, 297, 297, 297, 297, 297, 297, 
	297, 297, 297, 297, 280, 280, 280, 280, 
	280, 280, 280, 297, 297, 297, 297, 297, 
	297, 280, 280, 280, 280, 280, 280, 280, 
	280, 280, 280, 280, 280, 280, 280, 280, 
	280, 280, 280, 280, 280, 280, 280, 280, 
	280, 280, 280, 297, 297, 297, 297, 297, 
	297, 280, 280, 280, 280, 280, 280, 280, 
	280, 280, 280, 280, 280, 280, 280, 280, 
	280, 280, 280, 280, 280, 280, 280, 293, 
	280, 298, 298, 298, 298, 298, 298, 298, 
	298, 298, 298, 281, 281, 281, 281, 281, 
	281, 281, 298, 298, 298, 298, 298, 298, 
	281, 281, 281, 281, 281, 281, 281, 281, 
	281, 281, 281, 281, 281, 281, 281, 281, 
	281, 281, 281, 281, 281, 281, 281, 281, 
	281, 281, 298, 298, 298, 298, 298, 298, 
	281, 281, 281, 281, 281, 281, 281, 281, 
	281, 281, 281, 281, 281, 281, 281, 281, 
	281, 281, 281, 281, 281, 281, 293, 281, 
	299, 299, 299, 299, 299, 299, 299, 299, 
	299, 299, 282, 282, 282, 282, 282, 282, 
	282, 299, 299, 299, 299, 299, 299, 282, 
	282, 282, 282, 282, 282, 282, 282, 282, 
	282, 282, 282, 282, 282, 282, 282, 282, 
	282, 282, 282, 282, 282, 282, 282, 282, 
	282, 299, 299, 299, 299, 299, 299, 282, 
	282, 282, 282, 282, 282, 282, 282, 282, 
	282, 282, 282, 282, 282, 282, 282, 282, 
	282, 282, 282, 282, 282, 293, 282, 293, 
	161, 301, 300, 300, 300, 300, 300, 302, 
	300, 300, 300, 303, 303, 303, 303, 303, 
	303, 303, 303, 303, 300, 300, 304, 300, 
	166, 305, 305, 305, 305, 305, 305, 305, 
	305, 167, 167, 167, 167, 167, 167, 167, 
	167, 167, 167, 305, 305, 305, 305, 305, 
	305, 305, 167, 167, 167, 167, 167, 167, 
	167, 167, 167, 167, 167, 167, 167, 167, 
	167, 167, 167, 167, 167, 167, 167, 167, 
	167, 167, 167, 167, 305, 305, 305, 305, 
	167, 305, 167, 167, 167, 167, 167, 167, 
	167, 167, 167, 167, 167, 167, 167, 167, 
	167, 167, 167, 167, 167, 167, 167, 167, 
	167, 167, 167, 167, 305, 168, 168, 168, 
	168, 168, 168, 168, 168, 168, 305, 165, 
	305, 305, 305, 305, 305, 305, 168, 168, 
	168, 168, 168, 168, 168, 168, 168, 168, 
	305, 169, 169, 169, 169, 169, 169, 169, 
	169, 169, 169, 305, 305, 305, 305, 166, 
	305, 305, 169, 169, 169, 169, 169, 169, 
	169, 169, 169, 169, 169, 169, 169, 169, 
	169, 169, 169, 169, 169, 169, 169, 169, 
	169, 169, 169, 169, 305, 305, 305, 305, 
	169, 305, 169, 169, 169, 169, 169, 169, 
	169, 169, 169, 169, 169, 169, 169, 169, 
	169, 169, 169, 169, 169, 169, 169, 169, 
	169, 169, 169, 169, 305, 0
]

class << self
	attr_accessor :_re_scanner_trans_targs
	private :_re_scanner_trans_targs, :_re_scanner_trans_targs=
end
self._re_scanner_trans_targs = [
	142, 143, 3, 144, 5, 6, 145, 142, 
	7, 142, 142, 142, 9, 10, 142, 142, 
	142, 11, 142, 12, 142, 14, 20, 142, 
	15, 17, 19, 16, 18, 21, 23, 25, 
	22, 24, 0, 27, 26, 156, 29, 0, 
	30, 31, 46, 157, 32, 33, 34, 35, 
	40, 42, 44, 38, 36, 37, 39, 41, 
	43, 45, 158, 160, 162, 48, 51, 164, 
	50, 158, 158, 158, 55, 56, 158, 58, 
	59, 70, 74, 78, 82, 86, 90, 95, 
	99, 101, 104, 60, 67, 61, 65, 62, 
	63, 64, 158, 66, 68, 69, 71, 72, 
	73, 75, 76, 77, 79, 80, 81, 83, 
	84, 85, 87, 88, 89, 91, 93, 92, 
	94, 96, 97, 98, 100, 102, 103, 106, 
	107, 158, 170, 171, 110, 172, 112, 113, 
	173, 170, 115, 116, 178, 183, 180, 180, 
	119, 180, 184, 180, 180, 122, 185, 124, 
	180, 126, 129, 127, 128, 180, 130, 131, 
	132, 133, 134, 180, 186, 136, 187, 195, 
	204, 180, 180, 137, 212, 212, 138, 139, 
	140, 141, 1, 2, 4, 146, 147, 148, 
	149, 150, 142, 151, 142, 152, 153, 142, 
	154, 142, 155, 142, 142, 142, 142, 142, 
	8, 142, 142, 142, 142, 142, 142, 142, 
	142, 142, 142, 13, 142, 142, 28, 158, 
	159, 161, 163, 165, 158, 166, 167, 168, 
	169, 158, 158, 158, 158, 47, 49, 52, 
	158, 158, 53, 158, 158, 54, 57, 105, 
	108, 109, 111, 174, 175, 170, 175, 170, 
	170, 170, 176, 170, 177, 170, 114, 179, 
	170, 170, 180, 180, 181, 181, 180, 117, 
	120, 180, 180, 125, 135, 180, 182, 180, 
	180, 180, 180, 118, 180, 180, 121, 123, 
	180, 180, 180, 180, 188, 189, 190, 191, 
	192, 193, 194, 196, 197, 198, 199, 200, 
	201, 202, 203, 180, 205, 180, 206, 207, 
	208, 209, 210, 211, 212, 213, 214, 215, 
	216, 212
]

class << self
	attr_accessor :_re_scanner_trans_actions
	private :_re_scanner_trans_actions, :_re_scanner_trans_actions=
end
self._re_scanner_trans_actions = [
	1, 2, 0, 2, 0, 0, 2, 3, 
	0, 4, 5, 6, 7, 0, 8, 9, 
	10, 0, 11, 0, 12, 0, 0, 13, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 14, 0, 0, 0, 0, 0, 
	0, 0, 0, 16, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 17, 18, 18, 0, 0, 18, 
	0, 19, 20, 21, 0, 0, 22, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 23, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 24, 25, 26, 0, 26, 0, 0, 
	26, 27, 0, 0, 0, 18, 28, 29, 
	0, 30, 18, 31, 32, 0, 18, 0, 
	33, 0, 0, 0, 0, 34, 0, 0, 
	0, 0, 0, 35, 0, 0, 0, 0, 
	0, 36, 37, 0, 38, 39, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 18, 42, 43, 44, 0, 0, 45, 
	0, 46, 18, 47, 48, 49, 50, 51, 
	52, 53, 54, 55, 56, 57, 58, 59, 
	60, 61, 62, 0, 63, 64, 0, 66, 
	0, 18, 18, 0, 67, 0, 0, 18, 
	18, 68, 69, 70, 71, 0, 0, 0, 
	72, 73, 0, 74, 75, 0, 0, 0, 
	0, 0, 0, 0, 26, 76, 77, 78, 
	79, 80, 0, 81, 18, 82, 0, 18, 
	83, 84, 85, 86, 87, 88, 89, 0, 
	0, 90, 91, 0, 0, 92, 0, 93, 
	94, 95, 96, 0, 97, 98, 0, 0, 
	99, 100, 101, 102, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 18, 103, 0, 104, 0, 0, 
	0, 0, 0, 0, 105, 18, 18, 18, 
	18, 106
]

class << self
	attr_accessor :_re_scanner_to_state_actions
	private :_re_scanner_to_state_actions, :_re_scanner_to_state_actions=
end
self._re_scanner_to_state_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 40, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 65, 65, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 40, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 65, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 65, 0, 0, 0, 
	0
]

class << self
	attr_accessor :_re_scanner_from_state_actions
	private :_re_scanner_from_state_actions, :_re_scanner_from_state_actions=
end
self._re_scanner_from_state_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 41, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 41, 41, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 41, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 41, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 41, 0, 0, 0, 
	0
]

class << self
	attr_accessor :_re_scanner_eof_actions
	private :_re_scanner_eof_actions, :_re_scanner_eof_actions=
end
self._re_scanner_eof_actions = [
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 14, 14, 15, 15, 15, 15, 
	15, 15, 15, 15, 15, 15, 15, 15, 
	15, 15, 15, 15, 15, 15, 15, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 14, 0, 0, 
	14, 0, 0, 0, 0, 14, 14, 14, 
	14, 14, 14, 14, 14, 14, 14, 14, 
	14, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 14, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 14, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0
]

class << self
	attr_accessor :_re_scanner_eof_trans
	private :_re_scanner_eof_trans, :_re_scanner_eof_trans=
end
self._re_scanner_eof_trans = [
	0, 1, 1, 1, 1, 1, 1, 8, 
	11, 11, 11, 11, 11, 21, 21, 21, 
	21, 21, 21, 21, 21, 21, 21, 21, 
	21, 21, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 59, 
	59, 59, 59, 59, 59, 59, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 67, 67, 67, 67, 
	67, 67, 67, 67, 123, 123, 123, 123, 
	123, 123, 130, 130, 130, 0, 135, 135, 
	0, 140, 140, 140, 140, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 163, 165, 165, 165, 165, 0, 190, 
	190, 190, 190, 191, 191, 190, 190, 192, 
	194, 196, 198, 200, 205, 0, 0, 221, 
	221, 221, 221, 221, 221, 221, 221, 221, 
	221, 228, 0, 244, 244, 244, 244, 123, 
	244, 246, 249, 246, 0, 262, 264, 266, 
	269, 269, 273, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 276, 276, 276, 276, 
	276, 276, 276, 276, 292, 292, 292, 292, 
	292, 292, 292, 292, 0, 306, 306, 306, 
	306
]

class << self
	attr_accessor :re_scanner_start
end
self.re_scanner_start = 142;
class << self
	attr_accessor :re_scanner_first_final
end
self.re_scanner_first_final = 142;
class << self
	attr_accessor :re_scanner_error
end
self.re_scanner_error = 0;

class << self
	attr_accessor :re_scanner_en_unicode_property
end
self.re_scanner_en_unicode_property = 157;
class << self
	attr_accessor :re_scanner_en_character_set
end
self.re_scanner_en_character_set = 158;
class << self
	attr_accessor :re_scanner_en_set_escape_sequence
end
self.re_scanner_en_set_escape_sequence = 170;
class << self
	attr_accessor :re_scanner_en_escape_sequence
end
self.re_scanner_en_escape_sequence = 180;
class << self
	attr_accessor :re_scanner_en_conditional_expression
end
self.re_scanner_en_conditional_expression = 212;
class << self
	attr_accessor :re_scanner_en_main
end
self.re_scanner_en_main = 142;


# line 866 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
    
# line 1679 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner.rb"
begin
	p ||= 0
	pe ||= data.length
	cs = re_scanner_start
	top = 0
	ts = nil
	te = nil
	act = 0
end

# line 867 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
    
# line 1692 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner.rb"
begin
	testEof = false
	_slen, _trans, _keys, _inds, _acts, _nacts = nil
	_goto_level = 0
	_resume = 10
	_eof_trans = 15
	_again = 20
	_test_eof = 30
	_out = 40
	while true
	if _goto_level <= 0
	if p == pe
		_goto_level = _test_eof
		next
	end
	if cs == 0
		_goto_level = _out
		next
	end
	end
	if _goto_level <= _resume
	case _re_scanner_from_state_actions[cs] 
	when 41 then
# line 1 "NONE"
		begin
ts = p
		end
# line 1720 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner.rb"
	end
	_keys = cs << 1
	_inds = _re_scanner_index_offsets[cs]
	_slen = _re_scanner_key_spans[cs]
	_wide = data[p].ord
	_trans = if (   _slen > 0 && 
			_re_scanner_trans_keys[_keys] <= _wide && 
			_wide <= _re_scanner_trans_keys[_keys + 1] 
		    ) then
			_re_scanner_indicies[ _inds + _wide - _re_scanner_trans_keys[_keys] ] 
		 else 
			_re_scanner_indicies[ _inds + _slen ]
		 end
	end
	if _goto_level <= _eof_trans
	cs = _re_scanner_trans_targs[_trans]
	if _re_scanner_trans_actions[_trans] != 0
	case _re_scanner_trans_actions[_trans]
	when 14 then
# line 134 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin

    text = ts ? copy(data, ts-1..-1) : data.pack('c*')
    raise PrematureEndError.new( text )
  		end
	when 7 then
# line 147 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 self.group_depth = group_depth - 1; in_group = group_depth > 0 ? true : false 		end
	when 18 then
# line 1 "NONE"
		begin
te = p+1
		end
	when 16 then
# line 62 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/property.rl"
		begin
te = p+1
 begin 
      text = text(data, ts, te, 1).first
      if in_set
        type = :set
      else
        type = (text[1] == 'P') ^ (text[3] == '^') ? :nonproperty : :property
      end

      name = data[ts+2..te-2].pack('c*').gsub(/[\s_]/,'').downcase
      if name[0].chr == '^'
        name = name[1..-1]
      end

      case name
      # Named
      when 'alnum'
        self.emit(type, :alnum,       text, ts-1, te)
      when 'alpha'
        self.emit(type, :alpha,       text, ts-1, te)
      when 'ascii'
        self.emit(type, :ascii,       text, ts-1, te)
      when 'blank'
        self.emit(type, :blank,       text, ts-1, te)
      when 'cntrl'
        self.emit(type, :cntrl,       text, ts-1, te)
      when 'digit'
        self.emit(type, :digit,       text, ts-1, te)
      when 'graph'
        self.emit(type, :graph,       text, ts-1, te)
      when 'lower'
        self.emit(type, :lower,       text, ts-1, te)
      when 'print'
        self.emit(type, :print,       text, ts-1, te)
      when 'punct'
        self.emit(type, :punct,       text, ts-1, te)
      when 'space'
        self.emit(type, :space,       text, ts-1, te)
      when 'upper'
        self.emit(type, :upper,       text, ts-1, te)
      when 'word'
        self.emit(type, :word,        text, ts-1, te)
      when 'xdigit'
        self.emit(type, :xdigit,      text, ts-1, te)
      when 'xposixpunct'
        self.emit(type, :xposixpunct, text, ts-1, te)

      # Only in Oniguruma (old Rubies)
      when 'newline'
        self.emit(type, :newline,     text, ts-1, te)

      when 'any'
        self.emit(type, :any,         text, ts-1, te)
      when 'assigned'
        self.emit(type, :assigned,    text, ts-1, te)

      # Letters
      when 'l', 'letter'
        self.emit(type, :letter_any,       text, ts-1, te)
      when 'lu', 'uppercaseletter'
        self.emit(type, :letter_uppercase, text, ts-1, te)
      when 'll', 'lowercaseletter'
        self.emit(type, :letter_lowercase, text, ts-1, te)
      when 'lt', 'titlecaseletter'
        self.emit(type, :letter_titlecase, text, ts-1, te)
      when 'lm', 'modifierletter'
        self.emit(type, :letter_modifier,  text, ts-1, te)
      when 'lo', 'otherletter'
        self.emit(type, :letter_other,     text, ts-1, te)

      # Marks
      when 'm', 'mark'
        self.emit(type, :mark_any,         text, ts-1, te)
      when 'mn', 'nonspacingmark'
        self.emit(type, :mark_nonspacing,  text, ts-1, te)
      when 'mc', 'spacingmark'
        self.emit(type, :mark_spacing,     text, ts-1, te)
      when 'me', 'enclosingmark'
        self.emit(type, :mark_enclosing,   text, ts-1, te)

      # Numbers
      when 'n', 'number'
        self.emit(type, :number_any,       text, ts-1, te)
      when 'nd', 'decimalnumber'
        self.emit(type, :number_decimal,   text, ts-1, te)
      when 'nl', 'letternumber'
        self.emit(type, :number_letter,    text, ts-1, te)
      when 'no', 'othernumber'
        self.emit(type, :number_other,     text, ts-1, te)

      # Punctuation
      when 'p', 'punctuation'
        self.emit(type, :punct_any,        text, ts-1, te)
      when 'pc', 'connectorpunctuation'
        self.emit(type, :punct_connector,  text, ts-1, te)
      when 'pd', 'dashpunctuation'
        self.emit(type, :punct_dash,       text, ts-1, te)
      when 'ps', 'openpunctuation'
        self.emit(type, :punct_open,       text, ts-1, te)
      when 'pe', 'closepunctuation'
        self.emit(type, :punct_close,      text, ts-1, te)
      when 'pi', 'initialpunctuation'
        self.emit(type, :punct_initial,    text, ts-1, te)
      when 'pf', 'finalpunctuation'
        self.emit(type, :punct_final,      text, ts-1, te)
      when 'po', 'otherpunctuation'
        self.emit(type, :punct_other,      text, ts-1, te)

      # Symbols
      when 's', 'symbol'
        self.emit(type, :symbol_any,       text, ts-1, te)
      when 'sm', 'mathsymbol'
        self.emit(type, :symbol_math,      text, ts-1, te)
      when 'sc', 'currencysymbol'
        self.emit(type, :symbol_currency,  text, ts-1, te)
      when 'sk', 'modifiersymbol'
        self.emit(type, :symbol_modifier,  text, ts-1, te)
      when 'so', 'othersymbol'
        self.emit(type, :symbol_other,     text, ts-1, te)

      # Separators
      when 'z', 'separator'
        self.emit(type, :separator_any,    text, ts-1, te)
      when 'zs', 'spaceseparator'
        self.emit(type, :separator_space,  text, ts-1, te)
      when 'zl', 'lineseparator'
        self.emit(type, :separator_line,   text, ts-1, te)
      when 'zp', 'paragraphseparator'
        self.emit(type, :separator_para,   text, ts-1, te)

      # Codepoints
      when 'c', 'other'
        self.emit(type, :other,         text, ts-1, te)
      when 'cc', 'control'
        self.emit(type, :control,       text, ts-1, te)
      when 'cf', 'format'
        self.emit(type, :format,        text, ts-1, te)
      when 'cs', 'surrogate'
        self.emit(type, :surrogate,     text, ts-1, te)
      when 'co', 'privateuse'
        self.emit(type, :private_use,   text, ts-1, te)
      when 'cn', 'unassigned'
        self.emit(type, :unassigned,    text, ts-1, te)

      # Age
      when 'age=1.1'
        self.emit(type, :age_1_1,     text, ts-1, te)
      when 'age=2.0'
        self.emit(type, :age_2_0,     text, ts-1, te)
      when 'age=2.1'
        self.emit(type, :age_2_1,     text, ts-1, te)
      when 'age=3.0'
        self.emit(type, :age_3_0,     text, ts-1, te)
      when 'age=3.1'
        self.emit(type, :age_3_1,     text, ts-1, te)
      when 'age=3.2'
        self.emit(type, :age_3_2,     text, ts-1, te)
      when 'age=4.0'
        self.emit(type, :age_4_0,     text, ts-1, te)
      when 'age=4.1'
        self.emit(type, :age_4_1,     text, ts-1, te)
      when 'age=5.0'
        self.emit(type, :age_5_0,     text, ts-1, te)
      when 'age=5.1'
        self.emit(type, :age_5_1,     text, ts-1, te)
      when 'age=5.2'
        self.emit(type, :age_5_2,     text, ts-1, te)
      when 'age=6.0'
        self.emit(type, :age_6_0,     text, ts-1, te)
      when 'age=6.1'
        self.emit(type, :age_6_1,     text, ts-1, te)
      when 'age=6.2'
        self.emit(type, :age_6_2,     text, ts-1, te)
      when 'age=6.3'
        self.emit(type, :age_6_3,     text, ts-1, te)
      when 'age=7.0'
        self.emit(type, :age_7_0,     text, ts-1, te)
      when 'age=8.0'
        self.emit(type, :age_8_0,     text, ts-1, te)
      when 'age=9.0'
        self.emit(type, :age_9_0,     text, ts-1, te)
      when 'age=10.0'
        self.emit(type, :age_10_0,     text, ts-1, te)

      # Derived Properties
      when 'ahex', 'asciihexdigit'
        self.emit(type, :ascii_hex,                       text, ts-1, te)
      when 'alphabetic'
        self.emit(type, :alphabetic,                      text, ts-1, te)
      when 'cased'
        self.emit(type, :cased,                           text, ts-1, te)
      when 'cwcf', 'changeswhencasefolded'
        self.emit(type, :changes_when_casefolded,         text, ts-1, te)
      when 'cwcm', 'changeswhencasemapped'
        self.emit(type, :changes_when_casemapped,         text, ts-1, te)
      when 'cwl', 'changeswhenlowercased'
        self.emit(type, :changes_when_lowercased,         text, ts-1, te)
      when 'cwt', 'changeswhentitlecased'
        self.emit(type, :changes_when_titlecased,         text, ts-1, te)
      when 'cwu', 'changeswhenuppercased'
        self.emit(type, :changes_when_uppercased,         text, ts-1, te)
      when 'ci', 'caseignorable'
        self.emit(type, :case_ignorable,                  text, ts-1, te)
      when 'bidic', 'bidicontrol'
        self.emit(type, :bidi_control,                    text, ts-1, te)
      when 'dash'
        self.emit(type, :dash,                            text, ts-1, te)
      when 'dep', 'deprecated'
        self.emit(type, :deprecated,                      text, ts-1, te)
      when 'di', 'defaultignorablecodepoint'
        self.emit(type, :default_ignorable_cp,            text, ts-1, te)
      when 'dia', 'diacritic'
        self.emit(type, :diacritic,                       text, ts-1, te)
      when 'ext', 'extender'
        self.emit(type, :extender,                        text, ts-1, te)
      when 'grbase', 'graphemebase'
        self.emit(type, :grapheme_base,                   text, ts-1, te)
      when 'grext', 'graphemeextend'
        self.emit(type, :grapheme_extend,                 text, ts-1, te)
      when 'grlink', 'graphemelink' # NOTE: deprecated as of Unicode 5.0
        self.emit(type, :grapheme_link,                   text, ts-1, te)
      when 'hex', 'hexdigit'
        self.emit(type, :hex_digit,                       text, ts-1, te)
      when 'hyphen' # NOTE: deprecated as of Unicode 6.0
        self.emit(type, :hyphen,                          text, ts-1, te)
      when 'idc', 'idcontinue'
        self.emit(type, :id_continue,                     text, ts-1, te)
      when 'ideo', 'ideographic'
        self.emit(type, :ideographic,                     text, ts-1, te)
      when 'ids', 'idstart'
        self.emit(type, :id_start,                        text, ts-1, te)
      when 'idsb', 'idsbinaryoperator'
        self.emit(type, :ids_binary_op,                   text, ts-1, te)
      when 'idst', 'idstrinaryoperator'
        self.emit(type, :ids_trinary_op,                  text, ts-1, te)
      when 'joinc', 'joincontrol'
        self.emit(type, :join_control,                    text, ts-1, te)
      when 'loe', 'logicalorderexception'
        self.emit(type, :logical_order_exception,         text, ts-1, te)
      when 'lowercase'
        self.emit(type, :lowercase,                       text, ts-1, te)
      when 'math'
        self.emit(type, :math,                            text, ts-1, te)
      when 'nchar', 'noncharactercodepoint'
        self.emit(type, :non_character_cp,                text, ts-1, te)
      when 'oalpha', 'otheralphabetic'
        self.emit(type, :other_alphabetic,                text, ts-1, te)
      when 'odi', 'otherdefaultignorablecodepoint'
        self.emit(type, :other_default_ignorable_cp,      text, ts-1, te)
      when 'ogrext', 'othergraphemeextend'
        self.emit(type, :other_grapheme_extended,         text, ts-1, te)
      when 'oidc', 'otheridcontinue'
        self.emit(type, :other_id_continue,               text, ts-1, te)
      when 'oids', 'otheridstart'
        self.emit(type, :other_id_start,                  text, ts-1, te)
      when 'olower', 'otherlowercase'
        self.emit(type, :other_lowercase,                 text, ts-1, te)
      when 'omath', 'othermath'
        self.emit(type, :other_math,                      text, ts-1, te)
      when 'oupper', 'otheruppercase'
        self.emit(type, :other_uppercase,                 text, ts-1, te)
      when 'patsyn', 'patternsyntax'
        self.emit(type, :pattern_syntax,                  text, ts-1, te)
      when 'patws', 'patternwhitespace'
        self.emit(type, :pattern_whitespace,              text, ts-1, te)
      when 'qmark', 'quotationmark'
        self.emit(type, :quotation_mark,                  text, ts-1, te)
      when 'radical'
        self.emit(type, :radical,                         text, ts-1, te)
      when 'ri', 'regionalindicator'
        self.emit(type, :regional_indicator,              text, ts-1, te)
      when 'sd', 'softdotted'
        self.emit(type, :soft_dotted,                     text, ts-1, te)
      when 'sterm'
        self.emit(type, :sentence_terminal,               text, ts-1, te)
      when 'term', 'terminalpunctuation'
        self.emit(type, :terminal_punctuation,            text, ts-1, te)
      when 'uideo', 'unifiedideograph'
        self.emit(type, :unified_ideograph,               text, ts-1, te)
      when 'uppercase'
        self.emit(type, :uppercase,                       text, ts-1, te)
      when 'vs', 'variationselector'
        self.emit(type, :variation_selector,              text, ts-1, te)
      when 'wspace', 'whitespace'
        self.emit(type, :whitespace,                      text, ts-1, te)
      when 'xids', 'xidstart'
        self.emit(type, :xid_start,                       text, ts-1, te)
      when 'xidc', 'xidcontinue'
        self.emit(type, :xid_continue,                    text, ts-1, te)

      # Emoji
      when 'emoji'
        self.emit(type, :emoji_any,                       text, ts-1, te)
      when 'emojicomponent'
        self.emit(type, :emoji_component,                 text, ts-1, te)
      when 'emojimodifier'
        self.emit(type, :emoji_modifier,                  text, ts-1, te)
      when 'emojimodifierbase'
        self.emit(type, :emoji_modifier_base,             text, ts-1, te)
      when 'emojipresentation'
        self.emit(type, :emoji_presentation,              text, ts-1, te)

      # Scripts
      when 'aghb', 'caucasianalbanian'
        self.emit(type, :script_caucasian_albanian,       text, ts-1, te)
      when 'arab', 'arabic'
        self.emit(type, :script_arabic,                   text, ts-1, te)
      when 'armi', 'imperialaramaic'
        self.emit(type, :script_imperial_aramaic,         text, ts-1, te)
      when 'armn', 'armenian'
        self.emit(type, :script_armenian,                 text, ts-1, te)
      when 'avst', 'avestan'
        self.emit(type, :script_avestan,                  text, ts-1, te)
      when 'bali', 'balinese'
        self.emit(type, :script_balinese,                 text, ts-1, te)
      when 'bamu', 'bamum'
        self.emit(type, :script_bamum,                    text, ts-1, te)
      when 'bass', 'bassavah'
        self.emit(type, :script_bassa_vah,                text, ts-1, te)
      when 'batk', 'batak'
        self.emit(type, :script_batak,                    text, ts-1, te)
      when 'beng', 'bengali'
        self.emit(type, :script_bengali,                  text, ts-1, te)
      when 'bopo', 'bopomofo'
        self.emit(type, :script_bopomofo,                 text, ts-1, te)
      when 'brah', 'brahmi'
        self.emit(type, :script_brahmi,                   text, ts-1, te)
      when 'brai', 'braille'
        self.emit(type, :script_braille,                  text, ts-1, te)
      when 'bugi', 'buginese'
        self.emit(type, :script_buginese,                 text, ts-1, te)
      when 'buhd', 'buhid'
        self.emit(type, :script_buhid,                    text, ts-1, te)
      when 'cans', 'canadianaboriginal'
        self.emit(type, :script_canadian_aboriginal,      text, ts-1, te)
      when 'cari', 'carian'
        self.emit(type, :script_carian,                   text, ts-1, te)
      when 'cham'
        self.emit(type, :script_cham,                     text, ts-1, te)
      when 'cher', 'cherokee'
        self.emit(type, :script_cherokee,                 text, ts-1, te)
      when 'copt', 'coptic', 'qaac'
        self.emit(type, :script_coptic,                   text, ts-1, te)
      when 'cprt', 'cypriot'
        self.emit(type, :script_cypriot,                  text, ts-1, te)
      when 'cyrl', 'cyrillic'
        self.emit(type, :script_cyrillic,                 text, ts-1, te)
      when 'deva', 'devanagari'
        self.emit(type, :script_devanagari,               text, ts-1, te)
      when 'dsrt', 'deseret'
        self.emit(type, :script_deseret,                  text, ts-1, te)
      when 'dupl', 'duployan'
        self.emit(type, :script_duployan,                 text, ts-1, te)
      when 'egyp', 'egyptianhieroglyphs'
        self.emit(type, :script_egyptian_hieroglyphs,     text, ts-1, te)
      when 'elba', 'elbasan'
        self.emit(type, :script_elbasan,                  text, ts-1, te)
      when 'ethi', 'ethiopic'
        self.emit(type, :script_ethiopic,                 text, ts-1, te)
      when 'geor', 'georgian'
        self.emit(type, :script_georgian,                 text, ts-1, te)
      when 'glag', 'glagolitic'
        self.emit(type, :script_glagolitic,               text, ts-1, te)
      when 'goth', 'gothic'
        self.emit(type, :script_gothic,                   text, ts-1, te)
      when 'gran', 'grantha'
        self.emit(type, :script_grantha,                  text, ts-1, te)
      when 'grek', 'greek'
        self.emit(type, :script_greek,                    text, ts-1, te)
      when 'gujr', 'gujarati'
        self.emit(type, :script_gujarati,                 text, ts-1, te)
      when 'guru', 'gurmukhi'
        self.emit(type, :script_gurmukhi,                 text, ts-1, te)
      when 'hang', 'hangul'
        self.emit(type, :script_hangul,                   text, ts-1, te)
      when 'hani', 'han'
        self.emit(type, :script_han,                      text, ts-1, te)
      when 'hano', 'hanunoo'
        self.emit(type, :script_hanunoo,                  text, ts-1, te)
      when 'hebr', 'hebrew'
        self.emit(type, :script_hebrew,                   text, ts-1, te)
      when 'hira', 'hiragana'
        self.emit(type, :script_hiragana,                 text, ts-1, te)
      when 'hmng', 'pahawhhmong'
        self.emit(type, :script_pahawh_hmong,             text, ts-1, te)
      when 'hrkt', 'katakanaorhiragana'
        self.emit(type, :script_katakana_or_hiragana,     text, ts-1, te)
      when 'ital', 'olditalic'
        self.emit(type, :script_old_italic,               text, ts-1, te)
      when 'java', 'javanese'
        self.emit(type, :script_javanese,                 text, ts-1, te)
      when 'kali', 'kayahli'
        self.emit(type, :script_kayah_li,                 text, ts-1, te)
      when 'kana', 'katakana'
        self.emit(type, :script_katakana,                 text, ts-1, te)
      when 'khar', 'kharoshthi'
        self.emit(type, :script_kharoshthi,               text, ts-1, te)
      when 'khmr', 'khmer'
        self.emit(type, :script_khmer,                    text, ts-1, te)
      when 'khoj', 'khojki'
        self.emit(type, :script_khojki,                   text, ts-1, te)
      when 'knda', 'kannada'
        self.emit(type, :script_kannada,                  text, ts-1, te)
      when 'kthi', 'kaithi'
        self.emit(type, :script_kaithi,                   text, ts-1, te)
      when 'lana', 'taitham'
        self.emit(type, :script_tai_tham,                 text, ts-1, te)
      when 'laoo', 'lao'
        self.emit(type, :script_lao,                      text, ts-1, te)
      when 'latn', 'latin'
        self.emit(type, :script_latin,                    text, ts-1, te)
      when 'lepc', 'lepcha'
        self.emit(type, :script_lepcha,                   text, ts-1, te)
      when 'limb', 'limbu'
        self.emit(type, :script_limbu,                    text, ts-1, te)
      when 'lina', 'lineara'
        self.emit(type, :script_linear_a,                 text, ts-1, te)
      when 'linb', 'linearb'
        self.emit(type, :script_linear_b,                 text, ts-1, te)
      when 'lisu'
        self.emit(type, :script_lisu,                     text, ts-1, te)
      when 'lyci', 'lycian'
        self.emit(type, :script_lycian,                   text, ts-1, te)
      when 'lydi', 'lydian'
        self.emit(type, :script_lydian,                   text, ts-1, te)
      when 'mlym', 'malayalam'
        self.emit(type, :script_malayalam,                text, ts-1, te)
      when 'mahj', 'mahajani'
        self.emit(type, :script_mahajani,                 text, ts-1, te)
      when 'mand', 'mandaic'
        self.emit(type, :script_mandaic,                  text, ts-1, te)
      when 'mani', 'manichaean'
        self.emit(type, :script_manichaean,               text, ts-1, te)
      when 'mend', 'mendekikakui'
        self.emit(type, :script_mende_kikakui,            text, ts-1, te)
      when 'modi'
        self.emit(type, :script_modi,                     text, ts-1, te)
      when 'mong', 'mongolian'
        self.emit(type, :script_mongolian,                text, ts-1, te)
      when 'mroo', 'mro'
        self.emit(type, :script_mro,                      text, ts-1, te)
      when 'mtei', 'meeteimayek'
        self.emit(type, :script_meetei_mayek,             text, ts-1, te)
      when 'mymr', 'myanmar'
        self.emit(type, :script_myanmar,                  text, ts-1, te)
      when 'narb', 'oldnortharabian'
        self.emit(type, :script_old_north_arabian,        text, ts-1, te)
      when 'nbat', 'nabataean'
        self.emit(type, :script_nabataean,                text, ts-1, te)
      when 'nkoo', 'nko'
        self.emit(type, :script_nko,                      text, ts-1, te)
      when 'ogam', 'ogham'
        self.emit(type, :script_ogham,                    text, ts-1, te)
      when 'olck', 'olchiki'
        self.emit(type, :script_ol_chiki,                 text, ts-1, te)
      when 'orkh', 'oldturkic'
        self.emit(type, :script_old_turkic,               text, ts-1, te)
      when 'orya', 'oriya'
        self.emit(type, :script_oriya,                    text, ts-1, te)
      when 'osma', 'osmanya'
        self.emit(type, :script_osmanya,                  text, ts-1, te)
      when 'palm', 'palmyrene'
        self.emit(type, :script_palmyrene,                text, ts-1, te)
      when 'pauc', 'paucinhau'
        self.emit(type, :script_pau_cin_hau,              text, ts-1, te)
      when 'perm', 'oldpermic'
        self.emit(type, :script_old_permic,               text, ts-1, te)
      when 'phag', 'phagspa'
        self.emit(type, :script_phags_pa,                 text, ts-1, te)
      when 'phli', 'inscriptionalpahlavi'
        self.emit(type, :script_inscriptional_pahlavi,    text, ts-1, te)
      when 'phlp', 'psalterpahlavi'
        self.emit(type, :script_psalter_pahlavi,          text, ts-1, te)
      when 'phnx', 'phoenician'
        self.emit(type, :script_phoenician,               text, ts-1, te)
      when 'prti', 'inscriptionalparthian'
        self.emit(type, :script_inscriptional_parthian,   text, ts-1, te)
      when 'rjng', 'rejang'
        self.emit(type, :script_rejang,                   text, ts-1, te)
      when 'runr', 'runic'
        self.emit(type, :script_runic,                    text, ts-1, te)
      when 'samr', 'samaritan'
        self.emit(type, :script_samaritan,                text, ts-1, te)
      when 'sarb', 'oldsoutharabian'
        self.emit(type, :script_old_south_arabian,        text, ts-1, te)
      when 'saur', 'saurashtra'
        self.emit(type, :script_saurashtra,               text, ts-1, te)
      when 'shaw', 'shavian'
        self.emit(type, :script_shavian,                  text, ts-1, te)
      when 'sidd', 'siddham'
        self.emit(type, :script_siddham,                  text, ts-1, te)
      when 'sind', 'khudawadi'
        self.emit(type, :script_khudawadi,                text, ts-1, te)
      when 'sinh', 'sinhala'
        self.emit(type, :script_sinhala,                  text, ts-1, te)
      when 'sund', 'sundanese'
        self.emit(type, :script_sundanese,                text, ts-1, te)
      when 'sylo', 'sylotinagri'
        self.emit(type, :script_syloti_nagri,             text, ts-1, te)
      when 'syrc', 'syriac'
        self.emit(type, :script_syriac,                   text, ts-1, te)
      when 'tagb', 'tagbanwa'
        self.emit(type, :script_tagbanwa,                 text, ts-1, te)
      when 'tale', 'taile'
        self.emit(type, :script_tai_le,                   text, ts-1, te)
      when 'talu', 'newtailue'
        self.emit(type, :script_new_tai_lue,              text, ts-1, te)
      when 'taml', 'tamil'
        self.emit(type, :script_tamil,                    text, ts-1, te)
      when 'tavt', 'taiviet'
        self.emit(type, :script_tai_viet,                 text, ts-1, te)
      when 'telu', 'telugu'
        self.emit(type, :script_telugu,                   text, ts-1, te)
      when 'tfng', 'tifinagh'
        self.emit(type, :script_tifinagh,                 text, ts-1, te)
      when 'tglg', 'tagalog'
        self.emit(type, :script_tagalog,                  text, ts-1, te)
      when 'thaa', 'thaana'
        self.emit(type, :script_thaana,                   text, ts-1, te)
      when 'thai'
        self.emit(type, :script_thai,                     text, ts-1, te)
      when 'tibt', 'tibetan'
        self.emit(type, :script_tibetan,                  text, ts-1, te)
      when 'tirh', 'tirhuta'
        self.emit(type, :script_tirhuta,                  text, ts-1, te)
      when 'ugar', 'ugaritic'
        self.emit(type, :script_ugaritic,                 text, ts-1, te)
      when 'vaii', 'vai'
        self.emit(type, :script_vai,                      text, ts-1, te)
      when 'wara', 'warangciti'
        self.emit(type, :script_warang_citi,              text, ts-1, te)
      when 'xpeo', 'oldpersian'
        self.emit(type, :script_old_persian,              text, ts-1, te)
      when 'xsux', 'cuneiform'
        self.emit(type, :script_cuneiform,                text, ts-1, te)
      when 'yiii', 'yi'
        self.emit(type, :script_yi,                       text, ts-1, te)
      when 'zinh', 'inherited', 'qaai'
        self.emit(type, :script_inherited,                text, ts-1, te)
      when 'zyyy', 'common'
        self.emit(type, :script_common,                   text, ts-1, te)
      when 'zzzz', 'unknown'
        self.emit(type, :script_unknown,                  text, ts-1, te)

      # Unicode blocks
      when 'inalphabeticpresentationforms'
        self.emit(type, :block_inalphabetic_presentation_forms,           text, ts-1, te)
      when 'inarabicpresentationforms-a'
        self.emit(type, :block_inarabic_presentation_forms_a,             text, ts-1, te)
      when 'inarabicpresentationforms-b'
        self.emit(type, :block_inarabic_presentation_forms_b,             text, ts-1, te)
      when 'inarabic'
        self.emit(type, :block_inarabic,                                  text, ts-1, te)
      when 'inarmenian'
        self.emit(type, :block_inarmenian,                                text, ts-1, te)
      when 'inarrows'
        self.emit(type, :block_inarrows,                                  text, ts-1, te)
      when 'inbasiclatin'
        self.emit(type, :block_inbasic_latin,                             text, ts-1, te)
      when 'inbengali'
        self.emit(type, :block_inbengali,                                 text, ts-1, te)
      when 'inblockelements'
        self.emit(type, :block_inblock_elements,                          text, ts-1, te)
      when 'inbopomofoextended'
        self.emit(type, :block_inbopomofo_extended,                       text, ts-1, te)
      when 'inbopomofo'
        self.emit(type, :block_inbopomofo,                                text, ts-1, te)
      when 'inboxdrawing'
        self.emit(type, :block_inbox_drawing,                             text, ts-1, te)
      when 'inbraillepatterns'
        self.emit(type, :block_inbraille_patterns,                        text, ts-1, te)
      when 'inbuhid'
        self.emit(type, :block_inbuhid,                                   text, ts-1, te)
      when 'incjkcompatibilityforms'
        self.emit(type, :block_incjk_compatibility_forms,                 text, ts-1, te)
      when 'incjkcompatibilityideographs'
        self.emit(type, :block_incjk_compatibility_ideographs,            text, ts-1, te)
      when 'incjkcompatibility'
        self.emit(type, :block_incjk_compatibility,                       text, ts-1, te)
      when 'incjkradicalssupplement'
        self.emit(type, :block_incjk_radicals_supplement,                 text, ts-1, te)
      when 'incjksymbolsandpunctuation'
        self.emit(type, :block_incjk_symbols_and_punctuation,             text, ts-1, te)
      when 'incjkunifiedideographsextensiona'
        self.emit(type, :block_incjk_unified_ideographs_extension_a,      text, ts-1, te)
      when 'incjkunifiedideographs'
        self.emit(type, :block_incjk_unified_ideographs,                  text, ts-1, te)
      when 'incherokee'
        self.emit(type, :block_incherokee,                                text, ts-1, te)
      when 'incombiningdiacriticalmarksforsymbols'
        self.emit(type, :block_incombining_diacritical_marks_for_symbols, text, ts-1, te)
      when 'incombiningdiacriticalmarks'
        self.emit(type, :block_incombining_diacritical_marks,             text, ts-1, te)
      when 'incombininghalfmarks'
        self.emit(type, :block_incombining_half_marks,                    text, ts-1, te)
      when 'incontrolpictures'
        self.emit(type, :block_incontrol_pictures,                        text, ts-1, te)
      when 'incurrencysymbols'
        self.emit(type, :block_incurrency_symbols,                        text, ts-1, te)
      when 'incyrillicsupplement'
        self.emit(type, :block_incyrillic_supplement,                     text, ts-1, te)
      when 'incyrillic'
        self.emit(type, :block_incyrillic,                                text, ts-1, te)
      when 'indevanagari'
        self.emit(type, :block_indevanagari,                              text, ts-1, te)
      when 'indingbats'
        self.emit(type, :block_indingbats,                                text, ts-1, te)
      when 'inenclosedalphanumerics'
        self.emit(type, :block_inenclosed_alphanumerics,                  text, ts-1, te)
      when 'inenclosedcjklettersandmonths'
        self.emit(type, :block_inenclosed_cjk_letters_and_months,         text, ts-1, te)
      when 'inethiopic'
        self.emit(type, :block_inethiopic,                                text, ts-1, te)
      when 'ingeneralpunctuation'
        self.emit(type, :block_ingeneral_punctuation,                     text, ts-1, te)
      when 'ingeometricshapes'
        self.emit(type, :block_ingeometric_shapes,                        text, ts-1, te)
      when 'ingeorgian'
        self.emit(type, :block_ingeorgian,                                text, ts-1, te)
      when 'ingreekextended'
        self.emit(type, :block_ingreek_extended,                          text, ts-1, te)
      when 'ingreekandcoptic'
        self.emit(type, :block_ingreek_and_coptic,                        text, ts-1, te)
      when 'ingujarati'
        self.emit(type, :block_ingujarati,                                text, ts-1, te)
      when 'ingurmukhi'
        self.emit(type, :block_ingurmukhi,                                text, ts-1, te)
      when 'inhalfwidthandfullwidthforms'
        self.emit(type, :block_inhalfwidth_and_fullwidth_forms,           text, ts-1, te)
      when 'inhangulcompatibilityjamo'
        self.emit(type, :block_inhangul_compatibility_jamo,               text, ts-1, te)
      when 'inhanguljamo'
        self.emit(type, :block_inhangul_jamo,                             text, ts-1, te)
      when 'inhangulsyllables'
        self.emit(type, :block_inhangul_syllables,                        text, ts-1, te)
      when 'inhanunoo'
        self.emit(type, :block_inhanunoo,                                 text, ts-1, te)
      when 'inhebrew'
        self.emit(type, :block_inhebrew,                                  text, ts-1, te)
      when 'inhighprivateusesurrogates'
        self.emit(type, :block_inhigh_private_use_surrogates,             text, ts-1, te)
      when 'inhighsurrogates'
        self.emit(type, :block_inhigh_surrogates,                         text, ts-1, te)
      when 'inhiragana'
        self.emit(type, :block_inhiragana,                                text, ts-1, te)
      when 'inipaextensions'
        self.emit(type, :block_inipa_extensions,                          text, ts-1, te)
      when 'inideographicdescriptioncharacters'
        self.emit(type, :block_inideographic_description_characters,      text, ts-1, te)
      when 'inkanbun'
        self.emit(type, :block_inkanbun,                                  text, ts-1, te)
      when 'inkangxiradicals'
        self.emit(type, :block_inkangxi_radicals,                         text, ts-1, te)
      when 'inkannada'
        self.emit(type, :block_inkannada,                                 text, ts-1, te)
      when 'inkatakanaphoneticextensions'
        self.emit(type, :block_inkatakana_phonetic_extensions,            text, ts-1, te)
      when 'inkatakana'
        self.emit(type, :block_inkatakana,                                text, ts-1, te)
      when 'inkhmersymbols'
        self.emit(type, :block_inkhmer_symbols,                           text, ts-1, te)
      when 'inkhmer'
        self.emit(type, :block_inkhmer,                                   text, ts-1, te)
      when 'inlao'
        self.emit(type, :block_inlao,                                     text, ts-1, te)
      when 'inlatin-1supplement'
        self.emit(type, :block_inlatin_1_supplement,                      text, ts-1, te)
      when 'inlatinextended-a'
        self.emit(type, :block_inlatin_extended_a,                        text, ts-1, te)
      when 'inlatinextended-b'
        self.emit(type, :block_inlatin_extended_b,                        text, ts-1, te)
      when 'inlatinextendedadditional'
        self.emit(type, :block_inlatin_extended_additional,               text, ts-1, te)
      when 'inletterlikesymbols'
        self.emit(type, :block_inletterlike_symbols,                      text, ts-1, te)
      when 'inlimbu'
        self.emit(type, :block_inlimbu,                                   text, ts-1, te)
      when 'inlowsurrogates'
        self.emit(type, :block_inlow_surrogates,                          text, ts-1, te)
      when 'inmalayalam'
        self.emit(type, :block_inmalayalam,                               text, ts-1, te)
      when 'inmathematicaloperators'
        self.emit(type, :block_inmathematical_operators,                  text, ts-1, te)
      when 'inmiscellaneousmathematicalsymbols-a'
        self.emit(type, :block_inmiscellaneous_mathematical_symbols_a,    text, ts-1, te)
      when 'inmiscellaneousmathematicalsymbols-b'
        self.emit(type, :block_inmiscellaneous_mathematical_symbols_b,    text, ts-1, te)
      when 'inmiscellaneoussymbolsandarrows'
        self.emit(type, :block_inmiscellaneous_symbols_and_arrows,        text, ts-1, te)
      when 'inmiscellaneoussymbols'
        self.emit(type, :block_inmiscellaneous_symbols,                   text, ts-1, te)
      when 'inmiscellaneoustechnical'
        self.emit(type, :block_inmiscellaneous_technical,                 text, ts-1, te)
      when 'inmongolian'
        self.emit(type, :block_inmongolian,                               text, ts-1, te)
      when 'inmyanmar'
        self.emit(type, :block_inmyanmar,                                 text, ts-1, te)
      when 'innumberforms'
        self.emit(type, :block_innumber_forms,                            text, ts-1, te)
      when 'inogham'
        self.emit(type, :block_inogham,                                   text, ts-1, te)
      when 'inopticalcharacterrecognition'
        self.emit(type, :block_inoptical_character_recognition,           text, ts-1, te)
      when 'inoriya'
        self.emit(type, :block_inoriya,                                   text, ts-1, te)
      when 'inphoneticextensions'
        self.emit(type, :block_inphonetic_extensions,                     text, ts-1, te)
      when 'inprivateusearea'
        self.emit(type, :block_inprivate_use_area,                        text, ts-1, te)
      when 'inrunic'
        self.emit(type, :block_inrunic,                                   text, ts-1, te)
      when 'insinhala'
        self.emit(type, :block_insinhala,                                 text, ts-1, te)
      when 'insmallformvariants'
        self.emit(type, :block_insmall_form_variants,                     text, ts-1, te)
      when 'inspacingmodifierletters'
        self.emit(type, :block_inspacing_modifier_letters,                text, ts-1, te)
      when 'inspecials'
        self.emit(type, :block_inspecials,                                text, ts-1, te)
      when 'insuperscriptsandsubscripts'
        self.emit(type, :block_insuperscripts_and_subscripts,             text, ts-1, te)
      when 'insupplementalarrows-a'
        self.emit(type, :block_insupplemental_arrows_a,                   text, ts-1, te)
      when 'insupplementalarrows-b'
        self.emit(type, :block_insupplemental_arrows_b,                   text, ts-1, te)
      when 'insupplementalmathematicaloperators'
        self.emit(type, :block_insupplemental_mathematical_operators,     text, ts-1, te)
      when 'insyriac'
        self.emit(type, :block_insyriac,                                  text, ts-1, te)
      when 'intagalog'
        self.emit(type, :block_intagalog,                                 text, ts-1, te)
      when 'intagbanwa'
        self.emit(type, :block_intagbanwa,                                text, ts-1, te)
      when 'intaile'
        self.emit(type, :block_intai_le,                                  text, ts-1, te)
      when 'intamil'
        self.emit(type, :block_intamil,                                   text, ts-1, te)
      when 'intelugu'
        self.emit(type, :block_intelugu,                                  text, ts-1, te)
      when 'inthaana'
        self.emit(type, :block_inthaana,                                  text, ts-1, te)
      when 'inthai'
        self.emit(type, :block_inthai,                                    text, ts-1, te)
      when 'intibetan'
        self.emit(type, :block_intibetan,                                 text, ts-1, te)
      when 'inunifiedcanadianaboriginalsyllabics'
        self.emit(type, :block_inunified_canadian_aboriginal_syllabics,   text, ts-1, te)
      when 'invariationselectors'
        self.emit(type, :block_invariation_selectors,                     text, ts-1, te)
      when 'inyiradicals'
        self.emit(type, :block_inyi_radicals,                             text, ts-1, te)
      when 'inyisyllables'
        self.emit(type, :block_inyi_syllables,                            text, ts-1, te)
      when 'inyijinghexagramsymbols'
        self.emit(type, :block_inyijing_hexagram_symbols,                 text, ts-1, te)

      else
        # Should this really be an error? Or would emitting
        # an :unknown for the property be better?
        #
        # self.emit(type, :unknown, text, ts-1, te)

        raise UnknownUnicodePropertyError.new(name)
      end

      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 69 then
# line 153 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      set_type  = set_depth > 1 ? :subset : :set
      set_depth -= 1; in_set = set_depth > 0 ? true : false

      emit(set_type, :close, *text(data, ts, te))

      if set_depth == 0
        	begin
		cs = 142
		_goto_level = _again
		next
	end

      else
        	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

      end
     end
		end
	when 73 then
# line 166 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin  # special case, emits two tokens
      set_type  = set_depth > 1 ? :subset : :set
      set_depth -= 1; in_set = set_depth > 0 ? true : false

      emit(set_type, :member, copy(data, ts..te-2), ts, te)
      emit(set_type, :close,  copy(data, ts+1..te-1), ts, te)

      if set_depth == 0
        	begin
		cs = 142
		_goto_level = _again
		next
	end

      else
        	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

      end
     end
		end
	when 70 then
# line 180 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      text = text(data, ts, te).first
      if tokens.last[1] == :open
        emit(set_type, :negate, text, ts, te)
      else
        emit(set_type, :member, text, ts, te)
      end
     end
		end
	when 19 then
# line 189 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(set_type, :range, *text(data, ts, te))
     end
		end
	when 72 then
# line 193 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(set_type, :intersection, *text(data, ts, te))
     end
		end
	when 68 then
# line 197 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      	begin
		stack[top] = cs
		top+= 1
		cs = 170
		_goto_level = _again
		next
	end

     end
		end
	when 23 then
# line 209 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      text = text(data, ts, te).first

      class_name = text[2..-3]
      if class_name[0].chr == '^'
        class_name = "non#{class_name[1..-1]}"
      end

      token_sym = "class_#{class_name}".to_sym
      emit(set_type, token_sym, text, ts, te)
     end
		end
	when 22 then
# line 221 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(set_type, :collation, *text(data, ts, te))
     end
		end
	when 24 then
# line 225 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(set_type, :equivalent, *text(data, ts, te))
     end
		end
	when 67 then
# line 231 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(set_type, :member, *text(data, ts, te))
     end
		end
	when 66 then
# line 239 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(set_type, :member, *text(data, ts, te))
     end
		end
	when 75 then
# line 201 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      set_depth += 1; in_set = true
      set_type  = set_depth > 1 ? :subset : :set

      emit(set_type, :open, *text(data, ts, te))
      	begin
		stack[top] = cs
		top+= 1
		cs = 158
		_goto_level = _again
		next
	end

     end
		end
	when 71 then
# line 239 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      emit(set_type, :member, *text(data, ts, te))
     end
		end
	when 21 then
# line 201 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      set_depth += 1; in_set = true
      set_type  = set_depth > 1 ? :subset : :set

      emit(set_type, :open, *text(data, ts, te))
      	begin
		stack[top] = cs
		top+= 1
		cs = 158
		_goto_level = _again
		next
	end

     end
		end
	when 17 then
# line 239 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      emit(set_type, :member, *text(data, ts, te))
     end
		end
	when 80 then
# line 247 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(set_type, :backspace, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 78 then
# line 252 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      case text = text(data, ts, te, 1).first
      when '\d'; emit(set_type, :type_digit,     text, ts-1, te)
      when '\D'; emit(set_type, :type_nondigit,  text, ts-1, te)
      when '\h'; emit(set_type, :type_hex,       text, ts-1, te)
      when '\H'; emit(set_type, :type_nonhex,    text, ts-1, te)
      when '\s'; emit(set_type, :type_space,     text, ts-1, te)
      when '\S'; emit(set_type, :type_nonspace,  text, ts-1, te)
      when '\w'; emit(set_type, :type_word,      text, ts-1, te)
      when '\W'; emit(set_type, :type_nonword,   text, ts-1, te)
      when '\R'; emit(set_type, :type_linebreak, text, ts-1, te)
      when '\X'; emit(set_type, :type_xgrapheme, text, ts-1, te)
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 84 then
# line 268 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(set_type, :range_hex, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 76 then
# line 278 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(set_type, :escape, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 79 then
# line 283 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      p = p - 1;
      cs = 158;
      	begin
		stack[top] = cs
		top+= 1
		cs = 157
		_goto_level = _again
		next
	end

     end
		end
	when 83 then
# line 268 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      emit(set_type, :range_hex, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 82 then
# line 273 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      emit(set_type, :member_hex, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 81 then
# line 294 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      emit(set_type, :escape, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 27 then
# line 273 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      emit(set_type, :member_hex, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 25 then
# line 1 "NONE"
		begin
	case act
	when 0 then
	begin	begin
		cs = 0
		_goto_level = _again
		next
	end
end
	when 18 then
	begin begin p = ((te))-1; end

      emit(set_type, :escape, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

    end
	when 20 then
	begin begin p = ((te))-1; end

      emit(set_type, :escape, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

    end
end 
			end
	when 89 then
# line 304 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      text = text(data, ts, te, 1).first
      emit(:backref, :number, text, ts-1, te)
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 94 then
# line 310 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(:escape, :octal, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 86 then
# line 315 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      case text = text(data, ts, te, 1).first
      when '\.';  emit(:escape, :dot,               text, ts-1, te)
      when '\|';  emit(:escape, :alternation,       text, ts-1, te)
      when '\^';  emit(:escape, :bol,               text, ts-1, te)
      when '\$';  emit(:escape, :eol,               text, ts-1, te)
      when '\?';  emit(:escape, :zero_or_one,       text, ts-1, te)
      when '\*';  emit(:escape, :zero_or_more,      text, ts-1, te)
      when '\+';  emit(:escape, :one_or_more,       text, ts-1, te)
      when '\(';  emit(:escape, :group_open,        text, ts-1, te)
      when '\)';  emit(:escape, :group_close,       text, ts-1, te)
      when '\{';  emit(:escape, :interval_open,     text, ts-1, te)
      when '\}';  emit(:escape, :interval_close,    text, ts-1, te)
      when '\[';  emit(:escape, :set_open,          text, ts-1, te)
      when '\]';  emit(:escape, :set_close,         text, ts-1, te)
      when "\\\\";
        emit(:escape, :backslash, text, ts-1, te)
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 91 then
# line 336 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      # \b is emitted as backspace only when inside a character set, otherwise
      # it is a word boundary anchor. A syntax might "normalize" it if needed.
      case text = text(data, ts, te, 1).first
      when '\a'; emit(:escape, :bell,           text, ts-1, te)
      when '\e'; emit(:escape, :escape,         text, ts-1, te)
      when '\f'; emit(:escape, :form_feed,      text, ts-1, te)
      when '\n'; emit(:escape, :newline,        text, ts-1, te)
      when '\r'; emit(:escape, :carriage,       text, ts-1, te)
      when '\s'; emit(:escape, :space,          text, ts-1, te)
      when '\t'; emit(:escape, :tab,            text, ts-1, te)
      when '\v'; emit(:escape, :vertical_tab,   text, ts-1, te)
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 34 then
# line 352 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      text = text(data, ts, te, 1).first
      if text[2].chr == '{'
        emit(:escape, :codepoint_list, text, ts-1, te)
      else
        emit(:escape, :codepoint,      text, ts-1, te)
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 101 then
# line 362 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(:escape, :hex, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 104 then
# line 367 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(:escape, :hex_wide, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 36 then
# line 376 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      raise InvalidSequenceError.new("wide hex sequence")
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 30 then
# line 381 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      if data[te]
        c = data[te].chr
        if c =~ /[\x00-\x7F]/
          emit(:escape, :control, copy(data, ts-1..te), ts-1, te+1)
          p += 1
        else
          raise InvalidSequenceError.new("control sequence")
        end
      else
        raise PrematureEndError.new("control sequence")
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 33 then
# line 396 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      if data[te]
        c = data[te].chr
        if c =~ /[\x00-\x7F]/
          emit(:escape, :meta_sequence, copy(data, ts-1..te), ts-1, te+1)
          p += 1
        else
          raise InvalidSequenceError.new("meta sequence")
        end
      else
        raise PrematureEndError.new("meta sequence")
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 90 then
# line 411 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      p = p - 1;
      cs = 142;
      	begin
		stack[top] = cs
		top+= 1
		cs = 157
		_goto_level = _again
		next
	end

     end
		end
	when 85 then
# line 417 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(:escape, :literal, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 93 then
# line 310 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      emit(:escape, :octal, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 100 then
# line 362 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      emit(:escape, :hex, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 102 then
# line 376 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      raise InvalidSequenceError.new("wide hex sequence")
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 96 then
# line 381 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      if data[te]
        c = data[te].chr
        if c =~ /[\x00-\x7F]/
          emit(:escape, :control, copy(data, ts-1..te), ts-1, te+1)
          p += 1
        else
          raise InvalidSequenceError.new("control sequence")
        end
      else
        raise PrematureEndError.new("control sequence")
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 98 then
# line 396 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      if data[te]
        c = data[te].chr
        if c =~ /[\x00-\x7F]/
          emit(:escape, :meta_sequence, copy(data, ts-1..te), ts-1, te+1)
          p += 1
        else
          raise InvalidSequenceError.new("meta sequence")
        end
      else
        raise PrematureEndError.new("meta sequence")
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 37 then
# line 376 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      raise InvalidSequenceError.new("wide hex sequence")
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 29 then
# line 381 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      if data[te]
        c = data[te].chr
        if c =~ /[\x00-\x7F]/
          emit(:escape, :control, copy(data, ts-1..te), ts-1, te+1)
          p += 1
        else
          raise InvalidSequenceError.new("control sequence")
        end
      else
        raise PrematureEndError.new("control sequence")
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 32 then
# line 396 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      if data[te]
        c = data[te].chr
        if c =~ /[\x00-\x7F]/
          emit(:escape, :meta_sequence, copy(data, ts-1..te), ts-1, te+1)
          p += 1
        else
          raise InvalidSequenceError.new("meta sequence")
        end
      else
        raise PrematureEndError.new("meta sequence")
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 92 then
# line 1 "NONE"
		begin
	case act
	when 21 then
	begin begin p = ((te))-1; end

      text = text(data, ts, te, 1).first
      emit(:backref, :number, text, ts-1, te)
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

    end
	when 22 then
	begin begin p = ((te))-1; end

      emit(:escape, :octal, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

    end
end 
			end
	when 39 then
# line 427 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      text = text(data, ts, te-1).first
      emit(:conditional, :condition, text, ts, te-1)
      emit(:conditional, :condition_close, ')', te-1, te)
     end
		end
	when 105 then
# line 433 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      p = p - 1;
      	begin
		stack[top] = cs
		top+= 1
		cs = 142
		_goto_level = _again
		next
	end

     end
		end
	when 106 then
# line 433 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      p = p - 1;
      	begin
		stack[top] = cs
		top+= 1
		cs = 142
		_goto_level = _again
		next
	end

     end
		end
	when 38 then
# line 433 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      p = p - 1;
      	begin
		stack[top] = cs
		top+= 1
		cs = 142
		_goto_level = _again
		next
	end

     end
		end
	when 45 then
# line 446 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(:meta, :dot, *text(data, ts, te))
     end
		end
	when 48 then
# line 450 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      if in_conditional and conditional_stack.length > 0 and
         conditional_stack.last[1] == group_depth
        emit(:conditional, :separator, *text(data, ts, te))
      else
        emit(:meta, :alternation, *text(data, ts, te))
      end
     end
		end
	when 47 then
# line 461 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(:anchor, :bol, *text(data, ts, te))
     end
		end
	when 42 then
# line 465 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(:anchor, :eol, *text(data, ts, te))
     end
		end
	when 62 then
# line 469 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(:keep, :mark, *text(data, ts, te))
     end
		end
	when 60 then
# line 473 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      case text = text(data, ts, te).first
      when '\\A'; emit(:anchor, :bos,                text, ts, te)
      when '\\z'; emit(:anchor, :eos,                text, ts, te)
      when '\\Z'; emit(:anchor, :eos_ob_eol,         text, ts, te)
      when '\\b'; emit(:anchor, :word_boundary,      text, ts, te)
      when '\\B'; emit(:anchor, :nonword_boundary,   text, ts, te)
      when '\\G'; emit(:anchor, :match_start,        text, ts, te)
      else
        raise ScannerError.new(
          "Unexpected character in anchor at #{text} (char #{ts})")
      end
     end
		end
	when 61 then
# line 493 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      case text = text(data, ts, te).first
      when '\\d'; emit(:type, :digit,      text, ts, te)
      when '\\D'; emit(:type, :nondigit,   text, ts, te)
      when '\\h'; emit(:type, :hex,        text, ts, te)
      when '\\H'; emit(:type, :nonhex,     text, ts, te)
      when '\\s'; emit(:type, :space,      text, ts, te)
      when '\\S'; emit(:type, :nonspace,   text, ts, te)
      when '\\w'; emit(:type, :word,       text, ts, te)
      when '\\W'; emit(:type, :nonword,    text, ts, te)
      when '\\R'; emit(:type, :linebreak,  text, ts, te)
      when '\\X'; emit(:type, :xgrapheme,  text, ts, te)
      else
        raise ScannerError.new(
          "Unexpected character in type at #{text} (char #{ts})")
      end
     end
		end
	when 46 then
# line 514 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      set_depth += 1; in_set = true
      set_type  = set_depth > 1 ? :subset : :set

      emit(set_type, :open, *text(data, ts, te))
      	begin
		stack[top] = cs
		top+= 1
		cs = 158
		_goto_level = _again
		next
	end

     end
		end
	when 8 then
# line 526 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      text = text(data, ts, te).first

      in_conditional = true unless in_conditional
      conditional_depth += 1
      conditional_stack << [conditional_depth, group_depth]

      emit(:conditional, :open, text[0..-2], ts, te-1)
      emit(:conditional, :condition_open, '(', te-1, te)
      	begin
		stack[top] = cs
		top+= 1
		cs = 212
		_goto_level = _again
		next
	end

     end
		end
	when 9 then
# line 559 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      p = scan_options(p, data, ts, te)
     end
		end
	when 6 then
# line 569 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      case text = text(data, ts, te).first
      when '(?=';  emit(:assertion, :lookahead,    text, ts, te)
      when '(?!';  emit(:assertion, :nlookahead,   text, ts, te)
      when '(?<='; emit(:assertion, :lookbehind,   text, ts, te)
      when '(?<!'; emit(:assertion, :nlookbehind,  text, ts, te)
      end
     end
		end
	when 10 then
# line 586 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      case text = text(data, ts, te).first
      when '(?:';  emit(:group, :passive,      text, ts, te)
      when '(?>';  emit(:group, :atomic,       text, ts, te)
      when '(?~';  emit(:group, :absence,      text, ts, te)

      when /^\(\?<(\w*)>/
        empty_name_error(:group, 'named group (ab)') if $1.empty?

        emit(:group, :named_ab,  text, ts, te)

      when /^\(\?'(\w*)'/
        empty_name_error(:group, 'named group (sq)') if $1.empty?

        emit(:group, :named_sq,  text, ts, te)

      else
        raise ScannerError.new(
          "Unknown subexpression group format '#{text}'")
      end
     end
		end
	when 13 then
# line 638 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      case text = text(data, ts, te).first
      when /^\\([gk])<>/ # angle brackets
        empty_backref_error("ref/call (ab)")

      when /^\\([gk])''/ # single quotes
        empty_backref_error("ref/call (sq)")

      when /^\\([gk])<[^\d-](\w+)?>/ # angle-brackets
        if $1 == 'k'
          emit(:backref, :name_ref_ab,  text, ts, te)
        else
          emit(:backref, :name_call_ab,  text, ts, te)
        end

      when /^\\([gk])'[^\d-](\w+)?'/ #single quotes
        if $1 == 'k'
          emit(:backref, :name_ref_sq,  text, ts, te)
        else
          emit(:backref, :name_call_sq,  text, ts, te)
        end

      when /^\\([gk])<\d+>/ # angle-brackets
        if $1 == 'k'
          emit(:backref, :number_ref_ab,  text, ts, te)
        else
          emit(:backref, :number_call_ab,  text, ts, te)
        end

      when /^\\([gk])'\d+'/ # single quotes
        if $1 == 'k'
          emit(:backref, :number_ref_sq,  text, ts, te)
        else
          emit(:backref, :number_call_sq,  text, ts, te)
        end

      when /^\\([gk])<-\d+>/ # angle-brackets
        if $1 == 'k'
          emit(:backref, :number_rel_ref_ab,  text, ts, te)
        else
          emit(:backref, :number_rel_call_ab,  text, ts, te)
        end

      when /^\\([gk])'-\d+'/ # single quotes
        if $1 == 'k'
          emit(:backref, :number_rel_ref_sq,  text, ts, te)
        else
          emit(:backref, :number_rel_call_sq,  text, ts, te)
        end

      when /^\\k<[^\d-](\w+)?[+\-]\d+>/ # angle-brackets
        emit(:backref, :name_nest_ref_ab,  text, ts, te)

      when /^\\k'[^\d-](\w+)?[+\-]\d+'/ # single-quotes
        emit(:backref, :name_nest_ref_sq,  text, ts, te)

      when /^\\([gk])<\d+[+\-]\d+>/ # angle-brackets
        emit(:backref, :number_nest_ref_ab,  text, ts, te)

      when /^\\([gk])'\d+[+\-]\d+'/ # single-quotes
        emit(:backref, :number_nest_ref_sq,  text, ts, te)

      else
        raise ScannerError.new(
          "Unknown backreference format '#{text}'")
      end
     end
		end
	when 58 then
# line 709 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      case text = text(data, ts, te).first
      when '?' ;  emit(:quantifier, :zero_or_one,            text, ts, te)
      when '??';  emit(:quantifier, :zero_or_one_reluctant,  text, ts, te)
      when '?+';  emit(:quantifier, :zero_or_one_possessive, text, ts, te)
      end
     end
		end
	when 54 then
# line 717 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      case text = text(data, ts, te).first
      when '*' ;  emit(:quantifier, :zero_or_more,            text, ts, te)
      when '*?';  emit(:quantifier, :zero_or_more_reluctant,  text, ts, te)
      when '*+';  emit(:quantifier, :zero_or_more_possessive, text, ts, te)
      end
     end
		end
	when 56 then
# line 725 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      case text = text(data, ts, te).first
      when '+' ;  emit(:quantifier, :one_or_more,            text, ts, te)
      when '+?';  emit(:quantifier, :one_or_more_reluctant,  text, ts, te)
      when '++';  emit(:quantifier, :one_or_more_possessive, text, ts, te)
      end
     end
		end
	when 64 then
# line 733 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(:quantifier, :interval, *text(data, ts, te))
     end
		end
	when 4 then
# line 743 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      if free_spacing
        emit(:free_space, :comment, *text(data, ts, te))
      else
        append_literal(data, ts, te)
      end
     end
		end
	when 51 then
# line 608 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      text = text(data, ts, te).first
      emit(:group, :capture, text, ts, te)
     end
		end
	when 57 then
# line 709 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      case text = text(data, ts, te).first
      when '?' ;  emit(:quantifier, :zero_or_one,            text, ts, te)
      when '??';  emit(:quantifier, :zero_or_one_reluctant,  text, ts, te)
      when '?+';  emit(:quantifier, :zero_or_one_possessive, text, ts, te)
      end
     end
		end
	when 53 then
# line 717 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      case text = text(data, ts, te).first
      when '*' ;  emit(:quantifier, :zero_or_more,            text, ts, te)
      when '*?';  emit(:quantifier, :zero_or_more_reluctant,  text, ts, te)
      when '*+';  emit(:quantifier, :zero_or_more_possessive, text, ts, te)
      end
     end
		end
	when 55 then
# line 725 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      case text = text(data, ts, te).first
      when '+' ;  emit(:quantifier, :one_or_more,            text, ts, te)
      when '+?';  emit(:quantifier, :one_or_more_reluctant,  text, ts, te)
      when '++';  emit(:quantifier, :one_or_more_possessive, text, ts, te)
      end
     end
		end
	when 63 then
# line 733 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      emit(:quantifier, :interval, *text(data, ts, te))
     end
		end
	when 59 then
# line 739 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      	begin
		stack[top] = cs
		top+= 1
		cs = 180
		_goto_level = _again
		next
	end

     end
		end
	when 50 then
# line 751 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      if free_spacing
        emit(:free_space, :whitespace, *text(data, ts, te))
      else
        append_literal(data, ts, te)
      end
     end
		end
	when 49 then
# line 766 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      append_literal(data, ts, te)
     end
		end
	when 5 then
# line 608 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      text = text(data, ts, te).first
      emit(:group, :capture, text, ts, te)
     end
		end
	when 12 then
# line 739 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      	begin
		stack[top] = cs
		top+= 1
		cs = 180
		_goto_level = _again
		next
	end

     end
		end
	when 3 then
# line 766 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      append_literal(data, ts, te)
     end
		end
	when 1 then
# line 1 "NONE"
		begin
	case act
	when 0 then
	begin	begin
		cs = 0
		_goto_level = _again
		next
	end
end
	when 59 then
	begin begin p = ((te))-1; end

      append_literal(data, ts, te)
    end
end 
			end
	when 74 then
# line 134 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin

    text = ts ? copy(data, ts-1..-1) : data.pack('c*')
    raise PrematureEndError.new( text )
  		end
# line 201 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      set_depth += 1; in_set = true
      set_type  = set_depth > 1 ? :subset : :set

      emit(set_type, :open, *text(data, ts, te))
      	begin
		stack[top] = cs
		top+= 1
		cs = 158
		_goto_level = _again
		next
	end

     end
		end
	when 20 then
# line 134 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin

    text = ts ? copy(data, ts-1..-1) : data.pack('c*')
    raise PrematureEndError.new( text )
  		end
# line 201 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      set_depth += 1; in_set = true
      set_type  = set_depth > 1 ? :subset : :set

      emit(set_type, :open, *text(data, ts, te))
      	begin
		stack[top] = cs
		top+= 1
		cs = 158
		_goto_level = _again
		next
	end

     end
		end
	when 99 then
# line 134 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin

    text = ts ? copy(data, ts-1..-1) : data.pack('c*')
    raise PrematureEndError.new( text )
  		end
# line 362 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      emit(:escape, :hex, *text(data, ts, te, 1))
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 103 then
# line 134 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin

    text = ts ? copy(data, ts-1..-1) : data.pack('c*')
    raise PrematureEndError.new( text )
  		end
# line 376 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      raise InvalidSequenceError.new("wide hex sequence")
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 95 then
# line 134 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin

    text = ts ? copy(data, ts-1..-1) : data.pack('c*')
    raise PrematureEndError.new( text )
  		end
# line 381 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      if data[te]
        c = data[te].chr
        if c =~ /[\x00-\x7F]/
          emit(:escape, :control, copy(data, ts-1..te), ts-1, te+1)
          p += 1
        else
          raise InvalidSequenceError.new("control sequence")
        end
      else
        raise PrematureEndError.new("control sequence")
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 97 then
# line 134 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin

    text = ts ? copy(data, ts-1..-1) : data.pack('c*')
    raise PrematureEndError.new( text )
  		end
# line 396 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p
p = p - 1; begin 
      if data[te]
        c = data[te].chr
        if c =~ /[\x00-\x7F]/
          emit(:escape, :meta_sequence, copy(data, ts-1..te), ts-1, te+1)
          p += 1
        else
          raise InvalidSequenceError.new("meta sequence")
        end
      else
        raise PrematureEndError.new("meta sequence")
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 28 then
# line 134 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin

    text = ts ? copy(data, ts-1..-1) : data.pack('c*')
    raise PrematureEndError.new( text )
  		end
# line 381 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      if data[te]
        c = data[te].chr
        if c =~ /[\x00-\x7F]/
          emit(:escape, :control, copy(data, ts-1..te), ts-1, te+1)
          p += 1
        else
          raise InvalidSequenceError.new("control sequence")
        end
      else
        raise PrematureEndError.new("control sequence")
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 31 then
# line 134 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin

    text = ts ? copy(data, ts-1..-1) : data.pack('c*')
    raise PrematureEndError.new( text )
  		end
# line 396 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 begin p = ((te))-1; end
 begin 
      if data[te]
        c = data[te].chr
        if c =~ /[\x00-\x7F]/
          emit(:escape, :meta_sequence, copy(data, ts-1..te), ts-1, te+1)
          p += 1
        else
          raise InvalidSequenceError.new("meta sequence")
        end
      else
        raise PrematureEndError.new("meta sequence")
      end
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 35 then
# line 140 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin

    text = ts ? copy(data, ts-1..-1) : data.pack('c*')
    raise InvalidSequenceError.new('sequence', text)
  		end
# line 372 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      	begin
		top -= 1
		cs = stack[top]
		_goto_level = _again
		next
	end

     end
		end
	when 52 then
# line 147 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 self.group_depth = group_depth - 1; in_group = group_depth > 0 ? true : false 		end
# line 146 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 self.group_depth = group_depth + 1; in_group = true 		end
	when 11 then
# line 147 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 self.group_depth = group_depth - 1; in_group = group_depth > 0 ? true : false 		end
# line 544 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      emit(:group, :comment, *text(data, ts, te))
     end
		end
	when 44 then
# line 147 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 self.group_depth = group_depth - 1; in_group = group_depth > 0 ? true : false 		end
# line 613 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
te = p+1
 begin 
      if in_conditional and conditional_stack.last and
         conditional_stack.last[1] == (group_depth + 1)

        emit(:conditional, :close, *text(data, ts, te))
        conditional_stack.pop

        if conditional_stack.length == 0
          in_conditional = false
        end
      else
        if spacing_stack.length > 1 and
          spacing_stack.last[:depth] == (group_depth + 1)
          spacing_stack.pop

          self.free_spacing = spacing_stack.last[:free_spacing]
        end

        emit(:group, :close, *text(data, ts, te))
      end
     end
		end
	when 43 then
# line 1 "NONE"
		begin
te = p+1
		end
# line 146 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
 self.group_depth = group_depth + 1; in_group = true 		end
	when 77 then
# line 1 "NONE"
		begin
te = p+1
		end
# line 278 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
act = 18;		end
	when 26 then
# line 1 "NONE"
		begin
te = p+1
		end
# line 294 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
act = 20;		end
	when 88 then
# line 1 "NONE"
		begin
te = p+1
		end
# line 304 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
act = 21;		end
	when 87 then
# line 1 "NONE"
		begin
te = p+1
		end
# line 310 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
act = 22;		end
	when 2 then
# line 1 "NONE"
		begin
te = p+1
		end
# line 766 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin
act = 59;		end
# line 4175 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner.rb"
	end
	end
	end
	if _goto_level <= _again
	case _re_scanner_to_state_actions[cs] 
	when 65 then
# line 1 "NONE"
		begin
ts = nil;		end
	when 40 then
# line 1 "NONE"
		begin
ts = nil;		end
# line 1 "NONE"
		begin
act = 0
		end
# line 4193 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner.rb"
	end

	if cs == 0
		_goto_level = _out
		next
	end
	p += 1
	if p != pe
		_goto_level = _resume
		next
	end
	end
	if _goto_level <= _test_eof
	if p == eof
	if _re_scanner_eof_trans[cs] > 0
		_trans = _re_scanner_eof_trans[cs] - 1;
		_goto_level = _eof_trans
		next;
	end
	  case _re_scanner_eof_actions[cs]
	when 15 then
# line 54 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/property.rl"
		begin

    raise PrematureEndError.new('unicode property')
  		end
	when 14 then
# line 134 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"
		begin

    text = ts ? copy(data, ts-1..-1) : data.pack('c*')
    raise PrematureEndError.new( text )
  		end
# line 4227 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner.rb"
	  end
	end

	end
	if _goto_level <= _out
		break
	end
end
	end

# line 868 "/Users/jannoschmuller/code/regexp_parser/lib/regexp_parser/scanner/scanner.rl"

    if cs == re_scanner_error
      text = ts ? copy(data, ts-1..-1) : data.pack('c*')
      raise ScannerError.new("Scan error at '#{text}'")
    end

    raise PrematureEndError.new("(missing group closing paranthesis) "+
          "[#{in_group}:#{group_depth}]") if in_group
    raise PrematureEndError.new("(missing set closing bracket) "+
          "[#{in_set}:#{set_depth}]") if in_set

    # when the entire expression is a literal run
    emit_literal if literal

    tokens
  end

  # Emits an array with the details of the scanned pattern
  def emit(type, token, text, ts, te)
    #puts "EMIT: type: #{type}, token: #{token}, text: #{text}, ts: #{ts}, te: #{te}"

    emit_literal if literal

    if block
      block.call type, token, text, ts, te
    end

    tokens << [type, token, text, ts, te]
  end

  private

  attr_accessor :tokens, :literal, :block,
                :in_group, :group_depth,
                :free_spacing, :spacing_stack

  # Ragel's regex-based scan of the group options introduced a lot of
  # ambiguity, so we just ask it to find the beginning of what looks
  # like an options run and handle the rest in here.
  def scan_options(p, data, ts, te)
    text = text(data, ts, te).first

    options_char, options_length = true, 0

    # Copy while we have option characters. There is no maximum length,
    # as ruby allows things like '(?xxxxxxxxx-xxxxxxxxxxxxx:abc)'.
    negative_options = false
    while options_char
      if data[te + options_length]
        c = data[te + options_length].chr

        if c =~ /[-mixdau]/
          negative_options = true if c == '-'

          raise InvalidGroupOption.new(c, text) if negative_options and
            c =~ /[dau]/

          text << c ; p += 1 ; options_length += 1
        else
          options_char = false
        end
      else
        raise PrematureEndError.new("expression options `#{text}'")
      end
    end

    if data[te + options_length]
      c = data[te + options_length].chr

      if c == ':'
        # Include the ':' in the options text
        text << c ; p += 1 ; options_length += 1
        emit_options(text, ts, te + options_length)

      elsif c == ')'
        # Don't include the closing ')', let group_close handle it.
        emit_options(text, ts, te + options_length)

      else
        # Plain Regexp reports this as 'undefined group option'
        raise ScannerError.new(
          "Unexpected `#{c}' in options sequence, ':' or ')' expected")
      end
    else
      raise PrematureEndError.new("expression options `#{text}'")
    end

    p # return the new value of the data pointer
  end

  # Copy from ts to te from data as text
  def copy(data, range)
    data[range].pack('c*')
  end

  # Copy from ts to te from data as text, returning an array with the text
  #  and the offsets used to copy it.
  def text(data, ts, te, soff = 0)
    [copy(data, ts-soff..te-1), ts-soff, te]
  end

  # Appends one or more characters to the literal buffer, to be emitted later
  # by a call to emit_literal. Contents can be a mix of ASCII and UTF-8.
  def append_literal(data, ts, te)
    self.literal = literal || []
    literal << text(data, ts, te)
  end

  # Emits the literal run collected by calls to the append_literal method,
  # using the total start (ts) and end (te) offsets of the run.
  def emit_literal
    ts, te = literal.first[1], literal.last[2]
    text = literal.map {|t| t[0]}.join

    text.force_encoding('utf-8') if text.respond_to?(:force_encoding)

    self.literal = nil
    emit(:literal, :literal, text, ts, te)
  end

  def emit_options(text, ts, te)
    if text =~ /\(\?([mixdau]*)-?([mix]*)(:)?/
      positive, negative, group_local = $1, $2, $3

      if positive.include?('x')
        self.free_spacing = true
      end

      # If the x appears in both, treat it like ruby does, the second cancels
      # the first.
      if negative.include?('x')
        self.free_spacing = false
      end

      if group_local
        spacing_stack << {:free_spacing => free_spacing, :depth => group_depth}
      else
        # switch for parent group level
        spacing_stack.last[:free_spacing] = free_spacing
      end
    end

    emit(:group, :options, text, ts, te)
  end

  # Centralizes and unifies the handling of validation related
  # errors.
  def validation_error(type, what, reason)
    case type
    when :group
      error = InvalidGroupError.new(what, reason)
    when :backref
      error = InvalidBackrefError.new(what, reason)
    when :sequence
      error = InvalidSequenceError.new(what, reason)
    else
      error = ValidationError.new('expression')
    end

    raise error # unless @@config.validation_ignore
  end

  # Used for references with an empty name or number
  def empty_backref_error(type, what)
    validation_error(:backref, what, 'ref ID is empty')
  end

  # Used for named expressions with an empty name
  def empty_name_error(type, what)
    validation_error(type, what, 'name is empty')
  end

end # module Regexp::Scanner
